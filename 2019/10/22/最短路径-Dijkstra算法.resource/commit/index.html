<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="小寒的博客">
    <meta name="keyword" content="编程 GTD 自我管理">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        小寒丨isshl
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 醉后不知天在水，满船清梦压星河 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar radius">
            <img src="/img/avatar.png" />
        </div>
        <div class="name">
            <i>小寒</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 醉后不知天在水，满船清梦压星河 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-22 18:13:46</span></span>
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        {"compress":true,"commitItems":[["3de66b55-5f78-40d7-8b95-1a90d9198c85",1571739226894,"---\ntitle: 最短路径&Dijkstra算法\ndate: 2019-10-15 15:15:32\ntags:\n  - 算法\n---\n\n在无向图中，单点之间如果存在路径可达，求其中边数最少的路径，采用的算法是广度优先搜索。\n在有向图中，单点可达性和最短路径问题与无向图中的情况相似。\n而在加权无向图中，主要考虑的问题是最小生成树。最小生成树中已经包含单点可达性和最短路径问题。\n现在研究的加权有向图，则要关注的问题是最短路径问题。\n\n首先加权有向图是在有向图的基础上，赋予边以权重构成的图。\n最短路径表示的是在加权有向图中的顶点s到达顶点w点的一条路径，这条路径的权重最小。\n这条路径具有以下的性质：\n路径是有向的；\n权重不一定等价于距离；\n并不是所有的顶点都可达；\n负权重问题会是问题变得更复杂；\n最短路径一般是简单的；\n最短路径不是唯一的；\n可能会存在平行边和环。\n某个顶点的所有可达顶点的最短路径，构成了这个顶点的最短路径树。\n\n下面是加权有向边和加权有向图的数据结构。\n\n```java\n// 加权有向边\npublic class DirectedEdge {\n    private final int v;\n    private final int w;\n    private final double weight;\n\n    public DirectedEdge(int v, int w, double weight) {\n        if (v < 0)\n            throw new IllegalArgumentException(\"Vertex names must be nonnegative integers\");\n        if (w < 0)\n            throw new IllegalArgumentException(\"Vertex names must be nonnegative integers\");\n        if (Double.isNaN(weight))\n            throw new IllegalArgumentException(\"Weight is NaN\");\n        this.v = v;\n        this.w = w;\n        this.weight = weight;\n    }\n\n    public int from(){\n        return v;\n    }\n\n    public int to(){\n        return w;\n    }\n\n    public double weight(){\n        return weight;\n    }\n\n    public String toString(){\n        return v+ \"->\"+w+\" \"+String.format(\"%5.2f\", weight);\n    }\n}\n```\n\n```java\n// 加权有向图\nimport java.util.Stack;\npublic class EdgeWeightedDigraph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n\n    private final int V;\n    private int E;\n    private Bag<directededge>[] adj;\n    private int[] indegree;\n\n    public EdgeWeightedDigraph(int V) {\n        if (V < 0)\n            throw new IllegalArgumentException(\"Number of vertices in a Digraph must be nonnegative\");\n        this.V = V;\n        this.E = 0;\n        this.indegree = new int[V];\n        adj = (Bag<directededge>[]) new Bag[V];\n        for (int v = 0; v < V; v++) {\n            adj[v] = new Bag<directededge>();\n        }\n    }\n\n    public EdgeWeightedDigraph(int V, int E) {\n        this(V);\n        if (E < 0)\n            throw new IllegalArgumentException(\"Number of edges in a Digraph must be nonnegative\");\n        for (int i = 0; i < E; i++) {\n            int v = StdRandom.uniform(V);\n            int w = StdRandom.uniform(V);\n            double weight = 0.01*StdRandom.uniform(100);\n            DirectedEdge e = new DirectedEdge(v, w, weight);\n            addEdge(e);\n        }\n    }\n\n    public EdgeWeightedDigraph(In in){\n        this(in.readInt());\n        int E = in.readInt();\n        if (E < 0) throw new IllegalArgumentException(\"Number of edges must be nonnegative\");\n        for(int i=0;i<e;i++){\n int v="in.readInt();\n" w="in.readInt();\n" valiadtevertex(v);\n valiadtevertex(w);\n double weight="in.readDouble();\n" addedge(new directededge(v,w,weight));\n }\n }\n\n public edgeweighteddigraph(edgeweighteddigraph g){\n this(g.v());\n this.e="G.E();\n" for(int this.indegree[v]="G.indegree(v);\n" stack<directededge> reverse = new Stack<directededge>();\n            for(DirectedEdge e:G.adj[v])\n                reverse.push(e);\n            for(DirectedEdge e:reverse)\n                adj[v].add(e);    \n        }\n    }\n\n    public int V(){\n        return V;\n    }\n\n    public int E(){\n        return E;\n    }\n    // 添加边\n    public void addEdge(DirectedEdge e){\n        int v = e.from();\n        int w=e.to();\n        valiadteVertex(v);\n        valiadteVertex(w);\n        adj[v].add(e);\n        indegree[w]++;\n        E++;\n    }\n\n    public void valiadteVertex(int v){\n        if(v<0||v>=V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    public Iterable<directededge> adj(int v){\n        valiadteVertex(v);\n        return adj[v];\n    }\n    // 出度\n    public int outdegree(int v){\n        valiadteVertex(v);\n        return adj[v].size();\n    }\n    // 入度\n    public int indegree(int v){\n        valiadteVertex(v);\n        return indegree[v];\n    }\n    \n    public Iterable<directededge> edges(){\n        Bag<directededge> list = new Bag<directededge>();\n        for(int v=0;v<v;v++){\n for(directededge e:adj[v]){\n list.add(e);\n }\n return list;\n }\n\n public string tostring(){\n stringbuilder s="new" stringbuilder();\n s.append(v+\" \"+e+newline);\n for(int v="0;v<V;v++){\n" s.append(v+\": \");\n e:adj[v])\n s.append(e+\" s.append(newline);\n s.tostring();\n }\n}\n```\n\n\n而最短路径的数据结构就比较简单了。\n最短路径中的边：一个以顶点为索引的directededge对象的父链接数组edgeto[]，edgeto[v]表示v到它父结点的边。\n最短路径的距离：一个由顶点为索引的distto数组，distto[v]表示起点到顶点v的距离。\n\n而要找到加权有向图中的最短路径，是基于一个叫「放松」的基本操作。\n一开始，我们假设加权有向图中的顶点到起点的距离：起点为0，其他顶点到起点的距离都是无限远的。\n并且我们将顶点到起点的路径存储在edgeto中，而距离存储在distto中，随着算法的进行，包括「放松」的操作，\n路径和距离信息都会得到更新。\n\n而所谓「放松」操作：\n假设有向图中的有三个点，分别是起点s，顶点v，顶点w。倘若s可以到达v，也可以到达w，\n那么distto[w]即为s到w的距离，若v也可以到达w且v-w的边为e，\n放松v-w边：即检查s到w的最短路径，是否先从s到v，再由v到w，\n若不是，即distto[v]+e.weight()>=distTo[w]，则称边e失效忽略这条边，\n若是，即distTo[v]+e.weight()<distto[w]，则更新distto[w]=distto[v]+e.weight()。\n\n判断路径是否是最短路径的全局条件与放松一条边时所检测的局部条件是等价的。\n\ndijkstrasp算法的实现如下：\n构造方法中的索引优先队列会先插入打算计算最短路径的起点s，\n1. 然后将优先队列中距离起点最短的顶点删除，\n2. 再依次放松这个顶点发出的所有边，将其可达的顶点的相关信息存入distto和edgeto数组中，\n若该可达顶点不在优先队列中则将其加入，否则只更新相关信息。\n重复执行步骤 1, 2，直至优先队列为空。\n\njava代码实现：\n\n```java\n 有向图单点最短路径\nimport java.util.stack;\n\npublic class dijkstrasp {\n private double[] distto;\n directededge[] edgeto;\n indexminpq<double> pq;\n\n    public DijkstraSP(EdgeWeightedDigraph G, int s) {\n        for (DirectedEdge e : G.edges()) {// 不包含负权重边\n            if (e.weight() < 0)\n                throw new IllegalArgumentException(\"edge \" + e + \" has negative weight\");\n        }\n        distTo = new double[G.V()];\n        edgeTo = new DirectedEdge[G.V()];\n        \n        validateVertex(s);\n\n        for (int v = 0; v < G.V(); v++) {\n            distTo[v] = Double.POSITIVE_INFINITY;// 除起点外 图中其他的点距离起点的距离都是无限远\n        }\n        distTo[s] = 0;\n\n        pq = new IndexMinPQ<double>(G.V());\n        pq.insert(s, distTo[s]);\n        while (!pq.isEmpty()) {\n            int v = pq.delMin();\n            for (DirectedEdge e : G.adj(v)) {\n                relax(e);// 对v的邻接表内的每条边都进行放松\n            }\n        }\n\n         assert check(G, s);\n    }\n\n    \n    private void relax(DirectedEdge e) {\n        int v = e.from(), w = e.to();\n        if (distTo[w] > distTo[v] + e.weight()) {// 若从起点s到w的距离大于从s-v-s路径的权重 则更新数据\n            distTo[w] = distTo[v] + e.weight();\n            edgeTo[w] = e;\n            if (pq.contains(w))// 若优先队列中已包含w顶点则修改s到w的distTo[s]\n                pq.decreaseKey(w, distTo[w]);\n            else\n                pq.insert(w, distTo[w]);// 若不在优先队列中则添加进去\n        }\n    }\n\n    public double distTo(int v) {\n        validateVertex(v);\n        return distTo(v);\n    }\n\n    public boolean hasPathTo(int v) {\n        validateVertex(v);\n        return distTo[v] < Double.POSITIVE_INFINITY;\n    }\n\n    public Iterable<directededge> pathTo(int v) {\n        validateVertex(v);\n        if (!hasPathTo(v))\n            return null;\n        Stack<directededge> path = new Stack<directededge>();\n        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {\n            path.push(e);\n        }\n        return path;\n    }\n\n    \n    private boolean check(EdgeWeightedDigraph G, int s) {\n\n        // 负权重边检查\n        for (DirectedEdge e : G.edges()) {\n            if (e.weight() < 0) {\n                System.err.println(\"negative edge weight detected\");\n                return false;\n            }\n        }\n\n        // check that distTo[v] and edgeTo[v] are consistent\n        if (distTo[s] != 0.0 || edgeTo[s] != null) {\n            System.err.println(\"distTo[s] and edgeTo[s] inconsistent\");\n            return false;\n        }\n        for (int v = 0; v < G.V(); v++) {\n            if (v == s) continue;\n            if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {\n                System.err.println(\"distTo[] and edgeTo[] inconsistent\");\n                return false;\n            }\n        }\n\n        // check that all edges e = v->w satisfy distTo[w] <= distto[v] + e.weight()\n for (int v="0;" < g.v(); v++) {\n (directededge e : g.adj(v)) int w="e.to();\n" if (distto[v] e.weight() distto[w]) system.err.println(\"edge \" not relaxed\");\n return false;\n }\n }\n\n check that all edges>w on SPT satisfy distTo[w] == distTo[v] + e.weight()\n        for (int w = 0; w < G.V(); w++) {\n            if (edgeTo[w] == null) continue;\n            DirectedEdge e = edgeTo[w];\n            int v = e.from();\n            if (w != e.to()) return false;\n            if (distTo[v] + e.weight() != distTo[w]) {\n                System.err.println(\"edge \" + e + \" on shortest path not tight\");\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void validateVertex(int v){\n        int V =distTo.length;\n        if(v<0||v>=V){\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n        }\n    }\n}\n```\n",[[1571739214872,["x@x.local",[[-1,5302," "]],[5303,5303],[5302,5302]]],[1571739216837,["x@x.local",[[-1,5324,"."]],[5325,5325],[5324,5324]]],[1571739219119,["x@x.local",[[1,5324,"```\n.\n```"]],[5324,5324],[5333,5333]]],[1571739220201,["x@x.local",[[-1,5324,"```\n.\n```"]],[5333,5333],[5324,5324]]],[1571739221925,["x@x.local",[[1,5324,"》"]],[5324,5324],[5325,5325]]],[1571739222508,["x@x.local",[[-1,5324,"》"]],[5325,5325],[5324,5324]]],[1571739222915,["x@x.local",[[1,5324,"."]],[5324,5324],[5325,5325]]],[1571739224936,["x@x.local",[[-1,5325," "]],[5326,5326],[5325,5325]]]],null,"x@x.local"]]}</0||v></=></directededge></directededge></directededge></double></distto[w]，则更新distto[w]=distto[v]+e.weight()。\n\n判断路径是否是最短路径的全局条件与放松一条边时所检测的局部条件是等价的。\n\ndijkstrasp算法的实现如下：\n构造方法中的索引优先队列会先插入打算计算最短路径的起点s，\n1.></v;v++){\n></directededge></directededge></directededge></directededge></0||v></directededge></e;i++){\n></directededge></directededge></directededge>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <!--
    <ul class="list-inline text-center">
        
        

        

        

        

        
    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
        -->
    <p>
                <!--<a href="http://songchunlin.net/en" title="宋春林的英文站点" target="_blank">英文</a> ::
                <a href="http://www.zhihu.com/people/songcl" title="宋春林的知乎" target="_blank">知乎</a> ::-->
                <a href="http://weibo.com/ishanlog" title="小寒的微博" target="_blank">微博</a> ::
                <a href="mailto:shxheniaoan@gmail.com" title="小寒的Gmail邮箱" target="_blank">邮箱</a> ::
                <a href="http://www.douban.com/people/ishanlog/" title="小寒的豆瓣" target="_blank">豆瓣</a> ::
                <!--<a href="https://500px.com/songchunlin" title="宋春林的摄影相册" target="_blank">500px</a> ::-->
                <a href="https://github.com/isshl" title="小寒的GitHub" target="_blank">GitHub</a> ::
                <!--<a href="https://www.researchgate.net/profile/Chunlin_Song4" title="宋春林的 ResearchGate" target="_blank">ResearchGate</a> ::
                <a href="http://songchunlin.net/cn/feed/" title="RSS 订阅" target="_blank" >RSS</a>-->
                <a href="https://www.instagram.com/isshl/" title="小寒的instagram" target="_blank">Instagram</a>
    </p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


    <script>
        /**
         *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
         *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
        */
        if( '' || '')
        var disqus_config = function () {
            this.page.url = '';  // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };

        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://isshl.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>



</html>
