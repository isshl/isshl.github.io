[{"title":"快速排序(一)","url":"%2F2019%2F09%2F24%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F","content":"\n快速排序可能是应用最多的排序算法。原因包括：实现简单，速度快。\n其思想是将数组分成两个子数组，当两个子数组有序了，整个数组也就有序了。\n这个算法的关键在于切分。切分是将数组一分为二的关键。\n切分左侧的元素都不大于切分，切分右侧的元素都不小于切分。\n实现切分的方法是：先随意的选取一个元素当作切分元素，然后用指针 i 从数组的左端向右扫描，直至找到一个大于它的元素，再用指针 j 从数组的右端向左扫描，直至找到一个小于它的元素，然后交换这两个元素。如此继续，最终切分元素的左边都是不大于它的元素，右边都是不小于它的元素。当向左和向右扫描的两个指针相遇的时候，则将切分元素和左数组最右侧的元素交换，然后返回右指针 j 。\n排序的实现是：既然切分将数组分成了两个部分，然后继续递归的将子数组切分，最终整个数组变得有序。\nJava实现如下：\n\n```java\npublic class Quick {\n    private Quick() {\n    }\n\n    public static void sort(Comparable[] a) {\n        StdRandom.shuffle(a);\n        sort(a, 0, a.length - 1);\n        assert isSorted(a);\n    }\n\n    private static void sort(Comparable[] a, int lo, int hi) {\n        if (hi <= lo)\n            return;\n        int j = partition(a, lo, hi);\n        sort(a, lo, j - 1);\n        sort(a, j + 1, hi);\n        assert isSorted(a, lo, hi);\n    }\n\n    private static int partition(Comparable[] a, int lo, int hi) {\n        int i = lo;\n        int j = hi + 1;\n        Comparable v = a[lo];// 切分元素\n        while (true) {\n            while (less(a[++i], v)) {// 找到比切分元素大的元素\n                if (i == hi)\n                    break;\n            }\n\n            while (less(v, a[--j])) {// 找到比切分元素小的元素\n                if (j == lo)\n                    break;\n            }\n\n            if (i >= j)// i不能大于j\n                break;\n            exch(a, i, j);// 交换\n        }\n\n        exch(a, lo, j);\n\n        return j;\n    }\n\n    private static boolean less(Comparable a, Comparable b) {\n        return a.compareTo(b) < 0;\n    }\n\n    private static void exch(Object[] a, int i, int j) {\n        Object t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n    }\n\n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length - 1);\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = 0; i <= hi; i++) {\n            if (less(a[i], a[i--]))\n                return false;\n        }\n        return true;\n    }\n}\n```\n\n","tags":["算法"]},{"title":"归并排序(二)","url":"%2F2019%2F09%2F23%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E4%BA%8C%2F","content":"\n归并排序除了自顶而下的归并方式：「即将大问题分割成小问题，将小问题解决后再解决大问题」，还有另一种自底向上的归并方式。\n其思想是：先归并那些微型数组，然后再成对归并得到的子数组。如此直至归并了整个数组，排序结束。\n自底向上的归并排序适合用链表组织的数据。\n\n```java\npublic class MergeBU {\n\n    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\n        for (int k = 0; k <= hi; k++) {\n            aux[k] = a[k];\n        }\n\n        int i = lo, j = mid + 1;\n        for (int k = 0; k <= hi; k++) {\n            if (i > mid)\n                a[k] = aux[j++];\n            else if (j > hi)\n                a[k] = aux[i++];\n            else if (less(aux[j], aux[i]))\n                a[k] = aux[j++];\n            else\n                a[k] = aux[i++];\n        }\n    }\n\n    public static void sort(Comparable[] a) {\n        int n = a.length;\n        Comparable[] aux = new Comparable[n];\n        for (int len = 1; len < n; len *= 2) {// 子数组大小\n            // 子数组索引，其中lo+=len+len，表示子数组中的元素在数组中的最大索引值\n            for (int lo = 0; lo < n - len; lo += len + len) {\n                int mid = lo + len - 1;\n                int hi = Math.min(lo + len + len - 1, n - 1);\n                merge(a, aux, lo, mid, hi);\n            }\n        }\n    }\n\n    private static boolean less(Comparable a, Comparable b) {\n        return a.compareTo(b) < 0;\n    }\n\n    private static boolean isSorted(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            if (less(a[i], a[i - 1]))\n                return false;\n        }\n        return true;\n    }\n\n}\n```\n\n****\n","tags":["算法"]},{"title":"希尔排序与归并排序(一)","url":"%2F2019%2F09%2F23%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F","content":"\n在大规模乱序数组中插入排序很慢，因为它只会交换相邻的元素。\n希尔排序是在插入排序的基础上进行修改的。\n其思想是使数组中任意间隔为h的元素有序。排序的过程类似于插入排序但使用不同的增量。\n\n```java\npublic class Shell {\n    private Shell() {\n    }\n\n    public static void sort(Comparable[] a) {\n        int n = a.length;\n        int h = 1;\n        while (h < n / 3)\n            h = 3 * h + 1;// 计算最大的间隔值\n        while (h >= 1) {\n            for (int i = h; i < n; i++) {// 以不同增量进行的插入排序\n                for (int j = i; j >= h && less(a[j], a[j - h]); j -= h) {\n                    exch(a, j, j - h);\n                }\n            }\n            assert isHsorted(a, h);\n            h /= 3;// 改变增量，使数组中的不同h-子数组有序\n        }\n        assert isSorted(a);\n    }\n\n    private static boolean less(Comparable a, Comparable b) {\n        return a.compareTo(b) < 0;\n    }\n\n    private static void exch(Object[] a, int i, int j) {\n        Object t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n    }\n\n    private static boolean isSorted(Comparable[] a) {\n        for (int i = 1; i < a.length; i++) {\n            if (less(a[i], a[i - 1]))\n                return false;\n        }\n        return true;\n    }\n\n    private static boolean isHsorted(Comparable[] a, int h) {\n        for (int i = h; i < a.length; i++) {\n            if (less(a[i], a[i - h]))\n                return false;\n        }\n        return true;\n    }\n}\n```\n\n归并排序\n思想：将数组分成两半分别排序，再将结果归并起来。\n原地归并的抽象方法，是归并算法的核心。\nsort方法以递归的方式，将数组相邻的两个元素进行排序，在此基础上以此扩大排序的范围。\n```java\npublic class Merge {\n    private Merge() {\n    }\n\n    // 原地归并的抽象方法 \n    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\n        assert isSorted(a, lo, mid);\n        assert isSorted(a, mid + 1, hi);\n\n        for (int k = lo; k <= hi; k++) {\n            aux[k] = a[k];\n        }\n        int i = lo, j = mid + 1;\n        for (int k = lo; k <= hi; k++) {\n            // 将数组分为两半，依次比较两个数组的元素，然后将较小的结果存入原数组中\n            if (i > mid)// 左边取完，继续取右边的\n                a[k] = aux[j++];\n            else if (j > hi)// 右边取完，取左边的\n                a[k] = aux[i++];\n            else if (less(aux[j], aux[i]))// 当左右两边的数组都没有取完，且右边数组的元素较小，取右边的\n                a[k] = aux[j++];\n            else// 否则取左边的\n                a[k] = aux[i++];\n        }\n        assert isSorted(a, lo, hi);\n    }\n\n    public static void sort(Comparable[] a) {\n        Comparable[] aux = new Comparable[a.length];\n        sort(a, aux, 0, a.length - 1);\n        assert isSorted(a);\n\n    }\n\n    // 自顶向下的归并排序\n    private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {\n        if (hi <= lo)\n            return;\n        int mid = lo + (hi - lo) / 2;\n        sort(a, aux, lo, mid);// 数组的左半边排序，递归\n        sort(a, aux, mid + 1, hi);// 数组的右半边排序，递归\n        merge(a, aux, lo, mid, hi);// 原地归并\n    }\n\n    private static boolean less(Comparable a, Comparable b) {\n        return a.compareTo(b) < 0;\n    }\n\n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length - 1);\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = lo + 1; i <= hi; i++) {\n            if (less(a[i], a[i - 1]))\n                return false;\n        }\n        return true;\n    }\n}\n```\n\n\n","tags":["算法"]},{"title":"初级排序算法","url":"%2F2019%2F09%2F22%2F%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F","content":"\n**Algorithms**这本书花了不少时间阅读，终于在某个时间点读完了。虽说读完了，但之前读的东西基本上也都忘得差不多了。预计抽出一些时间，不定期将这本书中的算法思想和java实现更新到此博客上。\n这是第一篇。\n排序算法的基础。\n\n* * *\n选择排序\n思想：找到数组中最小的元素，然后和数组第一个元素交换位置。再次，找到数组中第二小的元素，然后和数组第二个元素交换位置。如此反复，直到整个数组排序。\n以下为Java的实现： _仅提供必要的代码_\n\n```java\nimport java.util.Comparator;\n\npublic class Selection {\n\n    private Selection() {\n\n    }\n\n    public void sort(Comparable[] a) {\n\n        int n = a.length;\n\n        for (int i = 0; i < n; i++) {// 选取数组的第一个元素\n\n            int min = i;\n\n            for (int j = i + 1; j < a.length; j++) {// 依次选取数组中剩余的元素\n\n                if (less(a[j], a[min]))\n\n                    min = j;// 选取数组中最小的元素\n\n            }\n\n            exch(a, i, min);\n\n            assert isSorted(a, 0, i);\n\n        }\n\n        assert isSorted(a);\n\n    }\n\n    private static boolean less(Comparable a, Comparable b) {\n\n        return a.compareTo(b) < 0;\n\n    }\n\n    private static void exch(Object[] a, int i, int j) {\n\n        Object t = a[i];\n\n        a[i] = a[j];\n\n        a[j] = t;\n\n    }\n\n    private static boolean isSorted(Comparable[] a) {\n\n        return isSorted(a, 0, a.length - 1);\n\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n\n        for (int i = 0; i < a.length; i++) {\n\n            if (less(a[i], a[i - 1]))\n\n                return false;\n\n        }\n\n        return true;\n\n    }\n\n}\n```\n\n插入算法\n思想：在一个数组中，把相邻的元素进行比较和交换，使各个元素处在恰当的位置上，直至此操作的索引到达数组的右端时，完成排序。\nJava实现：_仅提供必要的代码_\n\n```java\nimport java.util.Comparator;\n\npublic class Insertion {\n\n    public void sort(Comparable[] a) {\n\n        int n = a.length;\n\n        for (int i = 1; i < n; i++) {\n\n            for (int j = i; j > 0 && less(a[j], a[j - 1]); j--) {\n\n                exch(a, j, j - 1);\n\n            }\n\n            assert isSorted(a, 0, i);\n\n        }\n\n        assert isSorted(a);\n\n    }\n\n    private static boolean less(Comparable a, Comparable b) {\n\n        return a.compareTo(b) < 0;\n\n    }\n\n    private static void exch(Object[] a, int i, int j) {\n\n        Object t = a[i];\n\n        a[i] = a[j];\n\n        a[j] = t;\n\n    }\n\n    private static boolean isSorted(Comparable[] a) {\n\n        return isSorted(a, 0, a.length);\n\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n\n        for (int i = lo + 1; i < hi; i++)\n\n            if (less(a[i], a[i - 1]))\n\n                return false;\n\n        return true;\n\n    }\n\n}\n```\n\n","tags":["算法"]},{"title":"KMP算法","url":"%2F2019%2F07%2F30%2FKMP%E7%AE%97%E6%B3%95%2F","content":"\nKMP算法，花了不少时间去理解。\n网络上说这个算法的内容很多~\n例如阮一峰的[博文](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)，应该说他讲的很清楚，但没有实现，所以只能理解到其中的思想。和《算法》第四版中描述的内容是有差异的。\n《算法》第四版中的KMP内容理解起来会比较费劲。原因可能是因为中文的翻译有时候完全基于原文，内容之间的联系有些割裂，当然英文好的话，推荐英文好的直接看原版。\n\n假设有一个长字符串文本(文本)和一个短字符串文本(模式)，现在需要我们做的是判断这个文本中是否存在与模式一样的子字符串。\n\n通常的暴力算法：\n首先，文本和模式都有指向自己字符的指针，指针的作用是为了说明正在比较的字符的位置。\n然后，将文本的第一个字符与模式的第一个字符进行比较，若匹配成功则继续将文本的指针移向下一个位置，同时也将模式的指针移向下一个位置继续进行字符比较，直到模式指针指向模式字符串的最后一位字符，且与文本中指针指向的字符匹配为止，即匹配成功。若期间匹配失败，则将文本指针移动到上一次匹配起始位置的下一个位置，将模式指针移动到模式字符串起始位置，对这两个位置的字符进行比较，若匹配则继续比较下一个位置的字符，若不匹配则继续移动文本指针到上一次匹配起始位置下一个位置，并且将模式指针退回到起始位置，继续比较两个位置的字符是否匹配。\n通常暴力子字符串查找法，在长度为N的文本中查找长度为M的模式，最坏需要~NM次比较。\n实现如下：\n```java\npublic static int search(String pat,String txt){\n  int j,M=pat.length();\n  int i,N=txt.length();\n  for(i=0,j=0;i<N&&j<M;i++){//i-=j和i++表示不匹配，则从匹配的起始位置的下一位开始重新匹配\n    if(txt.charAt(i)==pat.charAt(j)) j++;\n    else{i -= j;j=0}\n  }\n  if(j==M) return i-M;//匹配成功\n  else     return N;//匹配失败\n}\n```\n\nKMP算法：\n首先，文本和模式都有指向自己字符的指针，指针是用来说明文本和模式的哪个位置的字符正在进行比较。\n其次，这个算法中存在一个记录匹配失败时模式指针 j 应该指向哪个位置的数组dfa[][]，这个数组在文本指针 i 和模式指针 j 指向的字符匹配时，\n\n```java\ndfa[txt.charAt(i)][j] = j+1\n```\n\n即和文本指针在第 i+1 处的字符比较的是模式指针在第 j+1 处的字符，或者说当文本和模式一直匹配`dfa[][j]`的值一直增加，最终 j = M (模式字符串最后一个字符的索引)，即匹配成功。\n若文本指针第 i 处的字符与模式指针第 j 处的字符不匹配，则我们可以得到以下信息：\n已经匹配的文本字符是什么。因为这部分文本字符和模式中的部分内容是匹配的，即模式字符串的前 j 个字符。\n这里应该说明，j 是模式字符串的索引，从0开始计算，当文本字符串的 i 处字符和模式字符串的 j 处字符不匹配时候，之前已经匹配的字符的数量是 j (0...j-1) 个。\n\n至此，我们仅仅知道的是若匹配则`dfa[][j]`的值是不断增加的，若文本和模式在某个位置不匹配， `dfa[][]`又是怎么判断模式指针该退回去多远呢？\nKMP算法的主要思想是：「模式字符串中的某处可以和匹配失败处的正文相匹配，那么就不应该完全跳过所有已经匹配的所有字符」。KMP算法会提前判断如何重新开始查找，而这种判断仅取决于模式本身。\n翻译成大白话就是：文本和模式在某处不匹配，但模式中的某处和匹配失败处的字符串匹配，那么我们就不应该跳过这部分已匹配的字符，而应该将模式字符串的指针移动到该处，然后继续下一位的字符匹配。假设文本和模式分别在第 i 处和第 j 处不匹配，又文本中从 i-j 处开始到 i 位置的字符是已知的且前面的 j 个字符都是匹配的，仅 第 i 个位置的字符和模式不匹配，其实这些问题最终只归结于模式本身，因为匹配的部分就是模式中的字符。\n\n这里要说明一个概念：确定有限状态自动机。\n其组成包括：\n一个非空有限的状态集合𝑄；\n一个输入字母表∑；\n一个转移函数𝜕；\n一个开始状态𝙨 ∈ 𝑄 ；\n一个接受状态的集合F ⊆ 𝑄；\n其工作方式：\n确定有限状态自动机从起始状态开始，一个字符接一个字符的读入一个字符串w ( w ∈ ∑ )，并根据给定的转移函数一步一步地转移至下一个状态。在读完该字符串后，如果该自动机停在一个属于F的接受状态，那么它就接受该字符串，反之则拒绝该字符串。\n\n回到KMP算法中，\ndfa[][]数组本身定义的就是一个*确定有限状态自动机*。\n根据算法第四版中的内容可知，\n「一个非空有限的状态集合𝑄」-> 模式字符串中的每个索引值代表一种状态；\n「一个输入字母表∑」 -> 模式字符串的字母表；\n「一个转移函数𝜕」 -> 即判断文本字符和模式字符是否匹配；\n「一个开始状态𝙨 ∈ 𝑄 」 -> 状态0；\n「一个接受状态的集合F ⊆ 𝑄；」-> 状态M，即模式指针移动到模式字符串最后一个字符且与文本匹配时的`dfa[][]`状态；\ndfa[][]的工作方式：\ndfa[][]从状态0开始，一个字符接一个字符的读入模式字符串，将这些字符一个一个与文本中的字符进行比较，如果模式中的字符和文本中的字符匹配，则状态会依次改变，当最终达到状态M(即模式指针指向模式最后一个字符且与文本内容匹配时)时候，则表明文本中找到了一段与模式匹配的子字符，否则文本中不存在与模式匹配的子字符串。\n我们拿文本和模式中的字符一一对比，`dfa[][]`的状态会发生变化。当字符匹配，模式指针向右移动一位,即`dfa[][]`的状态向前进；当出现不匹配的情况，则模式指针的向左移动，移动位置会根据当前`dfa[][]`所处的状态不同而不同。在以上两种情况下，文本指针的位置一直是向右移动。\n\n那么当文本和模式出现不匹配的时候，`dfa[][]`的值怎么确定呢？毕竟这是告诉我们模式指针该退回多远的关键。\n假设文本的第 i 处和模式的第 j 处不匹配，\n首先，我们应当理解，文本中已经和模式匹配的字符的数量是 j 个，位置在 i-j 到 i-1 之间。\n我们希望了解的是，如果退回了文本指针并右移了一位之后，重新扫描这部分字符，(这部分文本字符和模式字符是相同的，即pat.charAt(1)~pat.charAt(j-1)之间的字符) `dfa[][]`的状态是什么，这个状态又叫做*重启状态X*。\n为什么要忽略pat.charAt(0)呢，因为模式需要右移一位(文本指针右移一位)，为什么忽略pat.charAt(j)呢，因为这个字符是匹配失败的。\n显然对于匹配的字符数量不同，则重启状态X的值是不同的，即`dfa[][]`的值不同，模式指针退回多远也不一样。\n例如模式的字符串是 ABABAC，则\n当 j = 0 时，文本和模式不匹配，必然是文本指针向右移动一位，这里不存在重启状态X；\n当 j = 1 时，文本和模式不匹配，此时与模式匹配的字符A，去掉首字符和不匹配字符，然后将剩余字符(不存在)和模式进行匹配，`dfa[][]`=0，则X = 0；\n当 j = 2 时，文本和模式不匹配，此时与模式匹配的字符为AB，去掉首字符和不匹配字符，然后将剩余字符(B)和模式进行匹配，`dfa[][]`=0，则X = 0\n当 j = 3 时，文本和模式不匹配，此时与模式匹配的字符为ABA，去掉首字符和不匹配字符，然后将剩余字符(BA)和模式进行匹配，`dfa[][]`=1，去掉首字符和不匹配字符，则X = 1\n当 j = 4 时，文本和模式不匹配，此时与模式匹配的字符为ABAB，去掉首字符和不匹配字符，然后将剩余字符(BAB)和模式进行匹配，`dfa[][]`=2，去掉首字符和不匹配字符，则X = 2\n当 j = 5 时，文本和模式不匹配，此时与模式匹配的字符为ABABA，去掉首字符和不匹配字符，然后将剩余字符(BABA)和模式进行匹配，`dfa[][]`=3，去掉首字符和不匹配字符，则X = 3\nj 即使模式指针，也是状态。\n\n此时，我们已经确定在文本和模式不匹配的时候，模式指针应该退回多远，即退回到重启状态X的位置。\n当模式指针退回到重启状态X的位置时，会继续进行匹配。\njava的完整实现如下：\n```java\npublic class KMP {\n    private final int R;\n    private int[][] dfa;//记录文本和模式不匹配时候，模式指针退回多远的值\n\n    private char[] pattern;\n    private String pat;\n\n    public KMP(String pat) {\n        this.R = 256;\n        this.pat = pat;\n\n        int m = pat.length();\n        dfa = new int[R][m];\n        dfa[pat.charAt(0)][0] = 1;\n        for (int x = 0, j = 1; j < m; j++) {\n            for (int c = 0; c < R; c++) {\n                //不匹配 文本i位置的可以是除匹配字符以外的任意字符，但在此位置的重启状态X都是一样的\n                dfa[c][j] = dfa[c][x];\n            }\n            //匹配,就是说只有dfa[pat.charAt(j)][j]的项才会使状态前进，不匹配的都会经重新状态X转到合适的位置\n            dfa[pat.charAt(j)][j] = j + 1;\n            x = dfa[pat.charAt(j)][x];//更新X 不同状态，对应的重启状态X不一样\n        }\n    }\n\n    public KMP(char[] pattern, int R) {\n        this.R = R;\n        this.pattern = new char[pattern.length];\n        for (int j = 0; j < pattern.length; j++) {\n            this.pattern[j] = pattern[j];\n        }\n\n        int m = pattern.length;\n        dfa = new int[R][m];\n        dfa[pattern[0]][0] = 1;\n        for (int x = 0, j = 1; j < m; j++) {\n            for (int c = 0; c < R; c++) {\n                dfa[c][j] = dfa[c][x];//不匹配\n            }\n            dfa[pattern[j]][j] = j + 1;//匹配\n            x = dfa[pattern[j]][x];//模式不同位置，对应的重启状态X不一样\n        }\n    }\n\n    public int search(String txt) {\n        int m = pat.length();\n        int n = txt.length();\n        int i, j;\n        for (i = 0, j = 0; i < n && j < m; i++) {\n            //只有dfa[txt.charAt(i)][j]==dfa[pat.charAt(j)][j],j才会等于j+1,即匹配。其他的情况，j会退回到之前的位置\n            j = dfa[txt.charAt(i)][j];\n        }\n        if (j == m) return i - m;//发现\n        return n;//未发现\n    }\n\n    public int search(char[] text) {\n        int m = pattern.length;\n        int n = text.length;\n        int i, j;\n        for (i = 0, j = 0; i < n && j < m; i++) {\n            j = dfa[text[i]][j];\n        }\n        if (j == m) return i - m;//发现\n        return n;//未发现\n    }\n\n    public static void main(String[] args) {\n        String pat = args[0];\n        String txt = args[1];\n        char[] pattern = pat.toCharArray();\n        char[] text = txt.toCharArray();\n\n        KMP kmp1 = new KMP(pat);\n        int offset1 = kmp1.search(txt);\n\n        KMP kmp2 = new KMP(pattern, 256);\n        int offset2 = kmp2.search(text);\n\n        StdOut.println(\"text:   \" + txt);\n        StdOut.print(\"pattern: \");\n        for (int i = 0; i < offset1; i++)\n            StdOut.print(\" \");\n        StdOut.println(pat);\n\n        StdOut.print(\"pattern: \");\n        for (int i = 0; i < offset2; i++)\n            StdOut.println();\n        StdOut.println(pat);\n    }\n}\n```\n\n讲的并不是很清楚，待更新~","tags":["算法"]},{"title":"学习和时间管理","url":"%2F2019%2F07%2F20%2F%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%2F","content":"\n<div style=“text-align:center>\n    <table cellpadding=\"3\" cellspacing=\"0\" style=\"width: 60%;margin:auto\">\n        <td>\n            <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=298 height=52 src=\"//music.163.com/outchain/player?type=2&id=760541&auto=0&height=32\"> </iframe>\n        </td>\n    </table>\n</div>\n\n学习新技能是一件让人开心的事情。\n回想起学生时代，除了填鸭式死记硬背，从没想过别的学习方式。\n以此，学的不好可想而知。另一个原因是每次考试的时候心理压力太大。\n不知何时起，这种时间跨度比较大的反思或者反省常常会伴随着和自己的和解。\n因为知道自己怎么了，才能找办法解决。\n\n学习其实最关键的还是理解+重复的次数足够多。\n但重复多了，有时会怀疑自己，怎么这么蠢连这点东西都理解不了。\n进而受挫，也许最后就放弃了。\n\n知识分为两类：一种侧重于了解某事物的名称。一种侧重于理解某事物本身。\n其实高中学到的大部分知识，都是浅尝辄止式的广撒网。\n而对于理解某事物本身的知识，如果有人说「这个东西我理解，但是不知道怎么去表达或者说出来能让别人理解」，这恰恰说明他不理解。因为既然一个东西你完全掌握了，理应可以用浅显直白的语言说出它所有的性质。\n这里套用一句话：\n**「说他知道自己的想法但却无法表达的人, 通常并不知道他自己的想法。 」**-- Mortimer Adler\n![study](https://ishan.blog/img/study.jpg)\n从学习后知识的留存率来看，好为人师并不是坏事，你向别人说明一个事物的时候，正好可以用来检验你对所述内容的理解程度。\n当你向不熟悉某议题的人解释该议题的时候，以他们能理解的方式及最简单的语言向他们解释，\n倘若发现自己有不能理解的地方或者不能简单解释某议题的地方，恰恰这些是你对该议题理解薄弱的地方，\n这个时候应该回到原始材料中，重新学习理解薄弱的地方，一直到你能够以简单的语言来解释为止。\n重复以上步骤，直到你能完全理解这个议题为止。\n\n其实上面的内容，都是「费曼技巧」中的内容。\n而一旦你以这种方式去学习，\n其一，能够真正的了解任何你学习的事物。\n其二，做出深思熟虑并有智慧的决定。\n其三，熟练的将知识应用到实际问题中。\n\n以上~\n\n时间管理，是一个大的议题。相关的书籍很多很多。\n这些书所传述的「技能」，在现实生活中起多少作用，真的是靠自己如何将其和生活本身相结合了。\n时间就是生命~与其说是管理时间，不如说是管理好自己。\n以我自己来说，有时候觉得一丁点儿的娱乐都不应该存在，很大原因是觉得有好多东西需要去学习，成为更好的自己。\n所以玩一会，就觉得浪费时间。以前看过别人写的「为什么越努力越焦虑」，其核心的观点是：当你以「成为更好的自己」为目标，但「更好」并没有一个确切的定义，「更好」之外还有「更好」，你永远也达不到「最好」，最终努力成了目标本身，没有上限的目标一定会使你焦虑，一旦停止努力，就会陷入焦虑之中。\n但努力不是目标，它只是实现目标的手段。\n我们需要的，是具体确切的短期目标。\n尽量高效高质地完成短期目标，并及时收到反馈。这才是努力的正确姿势。\nvia--知乎:[以上观点来源链接](https://www.zhihu.com/question/37672919/answer/224810826)\n\n时间管理，本身应该结合实际的目标来制定。\n之前看《把时间当作朋友》一书，前3章的内容其实写的挺好，以下是关于此书的一点总结。\n\n背景：适用于短期或长期目标的实现\n1.制定可实现的目标\n2.倒推实现目标的步骤\n3.根据步骤制定任务\n4.将大的任务拆分成小的子任务\n5.将子任务拆分成更小的子任务--以最终可以完成为标准拆分\n6.将拆分的任务填入列表中\n7.估算任务的时间\n8.制定每日的任务列表\n9.执行\n\nTips:\n∙ 拆分任务应当遵循：做什么，为什么，怎么做 三原则。\n∙ 拆分任务后，应当寻找其中可以并行执行的任务，以提高效率。\n∙ 及时行动，立刻马上。\n∙ 每个任务：简单的部分应当迅速完成，困难部分多花时间。\n\n如果光说如何努力，或者光制定了计划而拖延执行，以上内容也就没了什么意义。\n之前浏览知乎，有搜到关于「如何保持自律」的内容。(ps:别问为什么又是知乎，问就是知乎干货多)\n\n假设存在6 7 8 9个坏习惯，比如熬夜、赖床、拖延......影响到你的自律，一般来说你肯定觉得要把这些坏习惯全部改掉，才能真正的自律。\n这样的思路，没错，但是实现起来很难。\n但其实，你只需要改变其中某个或者某些习惯即可，这些习惯一旦改变，则其他方面就会出现相应的改变，进而重塑生活/工作/学习方式。所以要找到影响你自律的最核心的坏习惯。\n「成功并不是要做对每一件事」，于我而言，其实跑步锻炼，就可以保持自律。\n所以，当你觉得自己不够自律的时候，请细心找找影响你自律最关键的习惯是什么，进而改变它，最终带来更多的改变。\n此处应推荐：[习惯的力量](https://zure.fun/book/8d41843e-4043-11e9-a197-560001e9d47e/)\n\n而其实「我就是不想做啊」更是生活常态。\n根据弗洛伊德的观点，每个人都存在「本我」「自我」「超我」的概念。\n偷懒拖延的本性，源于「本我」的「唯乐主义」。\n不断鞭策自己成长的是「超我」，是理想化的自己。\n而联系两者的是存在于中间的「自我」。\n请尝试将「超我」置于「管理者」和「引领者」的位置。\n本来作为「币圈大佬」的李笑来，人设已崩，而其写的那本《把时间当作朋友》，也不推荐读，前三章观点还可以，后面的章节写的非常乱，全是自我经验，与其费力去除其中的个人经验从而提炼出什么有价值的东西来，不如就别看。\n但其前三章中，有个观点是：我们可以用自己的大脑来控制我们的大脑。\n意思是，大脑本身是以「本我」的「唯乐主义」原则运行的，我们都「无意识地被自己的大脑所控制」，也就是「被负面情绪、唯乐主义指使，拖拖拉拉不愿做事」，我们应该意识到，「大脑」并不是「我自己」，而是属于「我」的，「我」是「我的大脑」的主人。\n也就是说，我们要意识到，自己在理性上具有主导地位。\n有意识地让「超我」去扮演「引领者」和「管理者」的角色，才是真正去主宰自己的生活。\n\n还有一种观点：「我」既是「我自己的老板」，也是「我自己的员工」。\n当你享受当老板时候的自我决策和掌控感时，也应该履行作为员工的职责。\n即我是我自己的老板，一切都是我说了算，我也是我自己的员工，我应该学会服从，\n**而不是想做就做，不想做就不做！**\n当然了，效果如何，还需实践~\n以上~\n\nPS: 评论系统来自Disqus，这玩意被防火墙封了。\nPPS:Pray for Kyoani.\n\n","tags":["时间管理"]},{"title":"一些回忆","url":"%2F2019%2F07%2F19%2F%E4%BD%A0%E4%B8%8D%E6%98%AF%E5%AD%A4%E5%8D%95%E4%B8%80%E4%B8%AA%E4%BA%BA%2F","content":"\n龙珠是小学时候看的，1996年以后，具体几年级忘了。\n小学时代，对这些动漫的第一印象就是：很帅。那种帅是说，正义终将胜利。\n印象中只记得关于龙珠的几个片段，\n其一，有个叫曹振的同学说「孙悟空最后当了神啊」，还有他那张幼稚的小脸印象深刻。\n其二，借了张齐玉同学的漫画书，那会晚上和奶奶一起睡，所以那次借了书后，看到了很晚。\n日光灯在北面墙上挂着，噼噼啪啪的总有虫子的撞击声，那会住在郊区。\n其他的诸如，天空之城、铁胆火车侠、奥特曼、EVA、美少女战士、数码宝贝、超能勇士、蓝猫淘气三千问、葫芦娃等等等，都没剩多少印象了，连看的过程中的片段都不记得一丝一毫。\n\n刚看完了龙珠超：布罗利。龙珠这部动漫，大概到大学的时候，才看完所有的动画，即便看的早。之后这些超，貌似不是鸟山明出的就没看。\n要说这些事情，包括小学初中在记忆里只剩下符号，没有多少具体意义。\n要给它们定个基调，就是我觉得我开窍的时间太晚，到了高中才明白一些事情。\n不是我不想开窍，是因为那时候的执念太深，也只有一个：不想多和别人交流。\n嘛，不过现在也好不到哪去。\n\n人总会在某些时候，怜惜自己。觉得自己很无辜很无助也很无力。\n你不是孤单一个人。很多人都会如此，并没有谁就一定会没有这些情绪。\n有些人走出来，是因为相信自己。或者不相信也没关系。\n只要你能找点事情去做，一旦忙起来，这些焦虑抑郁等负面情绪，根本没得时间去想。\n讨好型的人格，最终会因为受到的伤害太多，选择冷漠。这很常见，但也真的没必要。\n除了同班同学，人这一辈子遇到的人，不会超过2000，真正相识的能有几个？\n遇到坏人，并不代表始终会遇到坏人。不要走极端，听话。\n\n我前前后后读了至少十几本心理学科普书，这些只是「技」，但指导生活足够。\n决定你现在的，不是过去发生的事情，而是你透过过去发生的事情，在此刻做出选择的结果。\n每一个选择背后都会关联着一个目的。你选择什么是为了什么。而这个目的，最终个人猜测是潜意识里那些没有得到满足的需求，最核心的不过是「爱」。应该说，过去不管发生了什么，它们都是中立的，而你因为某些目的，特意选择了某些记忆，以此来说明自己是个什么样的人 。既然是自己的选择，就可以重新选择，唯独缺少的是勇气罢了。\n建议看看《被讨厌的勇气》，此书我看了5遍+。[喜马拉雅的地址](https://www.ximalaya.com/youshengshu/2749527/)\n\n阿德勒的心理学，固然不能回答所有问题，但他提供了一个思路，那就是以足够的勇气去追求更好的自己，其中也包括如何处理人际关系，如何面对心理阴影等等。这本书虽然不是他的著作，但作者是研究阿德勒心理学的学者，提炼出来的观点，有些足够颠覆一般的认知。\n\n我希望你很好。\n以上~\n\n* * *\n日志\n修改内容：「标题」\n修改时间：2019年09月23日09:57:07\n\n\n\n","tags":["动漫"]},{"title":"从某次搜索谈起","url":"%2F2019%2F07%2F15%2F%E4%BB%8E%E6%9F%90%E6%AC%A1%E6%90%9C%E7%B4%A2%E8%B0%88%E8%B5%B7%2F","content":"　　之前有想法是从底层构建一个博客，后来想想工程量有点大，有现成的工具和框架不必花那些时间了。\n　　偶然某次搜索，搜到了一个博士建的博客站点。于是揣着一点好奇，把里面的文章随机浏览了一遍。\n　　[博客地址](http://songchunlin.net/cn/archive/)\n　　内容多数是关于生活的。技术类涉及不多，毕竟非CS类。\n　　博客的Timeline，是从2013年开始的。\n　　有一段时间，对于时间很敏感。因为以前浪费多了，觉得浪费一丁点儿都心疼，即便在没有事情做的时候，也很少会看点休闲的东西。这一年多，没有看完一部美剧或日剧。电影只完整看完了《流浪地球》。读书，kindle里存书太多，某些不值得看的书顺手删掉，细读的也不是特别多，只不过睡前总要翻几页。\n　　从某些方面来说，我相信除了那些天赋上必须具备条件的事情，一般而言，可以后天学习得到的，就一定可以获得的。至于是否值得践行「1万小时理论」，前段时间读的刻意学习更适合。而就学习这件事来说，质量的高低，和人是否主动投入很大关系。说到底，重复才是学习的精髓。当了那么多年学生，从来没把学习当作很重要的事情来看，也没有什么学习技巧。随波逐流的学，想当然的觉得这些东西没什么，最终会以各种形式影响到自己的生活。环境是非常重要的一件事情。\n　　知乎上有人说，一旦你开始锻炼，那么你的年龄将保持在你锻炼的那个阶段。事实上，锻炼最大的好处是可以化解很多不必要的负面情绪。我一直鼓励身边的人运动。至少我自己每周保持运动5次，每次30分钟不等。\n　　说回上面的博客，因为对页面的简洁有那么一丝要求。\n　　之前Hexo搭配的NexT主题，很常见。搞hackintosh的时候翻教程，十个里面有九个是这个主题，或是这个主题的魔改。github的加载速度，国内一言难尽，时快时慢，甚至我挂了梯子，也不快。\n　　Hexo的主题，文件目录和内容比较固定，稍微套用了下博主的主题。\n　　于是很顺利搭建完成。\n　　对于markdown的使用，各种标记的使用还不熟。纯文字倒没什么。\n　　域名和梯子有一点花费。\n　　不过Hexo+Github建博客很容易，甚至域名都可以不用绑定，直接用github.io。\n　　希望能一直写下去。\n 　    (完)\n* * *\n日志\n修改内容：删除部分多余文字\n修改时间：2019年09月23日10:04:18\n\n\n","tags":["技术应用"]},{"title":"关于一些问题的思考","url":"%2F2019%2F07%2F15%2F%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83%2F","content":"\n存在是客观的，但意义是空虚的。\n没有必要问出生活的意义是什么，创造了什么便是意义的全部。\n你是你选择的结果。\n主观的选择，背后一定有其目的。\n现在的你并不是由过去决定的，而是由当下的你决定的。\n你是先有的目的，再从过去寻找原因。\n换句话说，决定我们自身的不是过去的经历，而是我们赋予这些经历的意义。\n既然赋予是我们的选择，就可以再选一次。\n心理创伤本身也不存在，它是为了支持我们的目的而存在。不过感受是主观的，经历是客观的。\n你以为难的事情，做的时候，也许感到的是「不过如此」。\n","tags":["生活"]}]