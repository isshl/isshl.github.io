[{"title":"Bellman-Ford算法","url":"%2F2019%2F10%2F15%2FBellman-Ford%E7%AE%97%E6%B3%95%2F","content":"~待更新\n","tags":["算法"]},{"title":"最短路径&Dijkstra算法","url":"%2F2019%2F10%2F15%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Dijkstra%E7%AE%97%E6%B3%95%2F","content":"\n在无向图中，单点之间如果存在路径可达，求其中边数最少的路径，采用的算法是广度优先搜索。\n在有向图中，单点可达性和最短路径问题与无向图中的情况相似。\n而在加权无向图中，主要考虑的问题是最小生成树。最小生成树中已经包含单点可达性和最短路径问题。\n现在研究的加权有向图，则要关注的问题是最短路径问题。\n\n首先加权有向图是在有向图的基础上，赋予边以权重构成的图。\n最短路径表示的是在加权有向图中的顶点s到达顶点w点的一条路径，这条路径的权重最小。\n这条路径具有以下的性质：\n路径是有向的；\n权重不一定等价于距离；\n并不是所有的顶点都可达；\n负权重问题会是问题变得更复杂；\n最短路径一般是简单的；\n最短路径不是唯一的；\n可能会存在平行边和环。\n某个顶点的所有可达顶点的最短路径，构成了这个顶点的最短路径树。\n\n下面是加权有向边和加权有向图的数据结构。\n\n```java\n// 加权有向边\npublic class DirectedEdge {\n    private final int v;\n    private final int w;\n    private final double weight;\n\n    public DirectedEdge(int v, int w, double weight) {\n        if (v < 0)\n            throw new IllegalArgumentException(\"Vertex names must be nonnegative integers\");\n        if (w < 0)\n            throw new IllegalArgumentException(\"Vertex names must be nonnegative integers\");\n        if (Double.isNaN(weight))\n            throw new IllegalArgumentException(\"Weight is NaN\");\n        this.v = v;\n        this.w = w;\n        this.weight = weight;\n    }\n\n    public int from(){\n        return v;\n    }\n\n    public int to(){\n        return w;\n    }\n\n    public double weight(){\n        return weight;\n    }\n\n    public String toString(){\n        return v+ \"->\"+w+\" \"+String.format(\"%5.2f\", weight);\n    }\n}\n```\n\n```java\n// 加权有向图\nimport java.util.Stack;\npublic class EdgeWeightedDigraph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n\n    private final int V;\n    private int E;\n    private Bag<DirectedEdge>[] adj;\n    private int[] indegree;\n\n    public EdgeWeightedDigraph(int V) {\n        if (V < 0)\n            throw new IllegalArgumentException(\"Number of vertices in a Digraph must be nonnegative\");\n        this.V = V;\n        this.E = 0;\n        this.indegree = new int[V];\n        adj = (Bag<DirectedEdge>[]) new Bag[V];\n        for (int v = 0; v < V; v++) {\n            adj[v] = new Bag<DirectedEdge>();\n        }\n    }\n\n    public EdgeWeightedDigraph(int V, int E) {\n        this(V);\n        if (E < 0)\n            throw new IllegalArgumentException(\"Number of edges in a Digraph must be nonnegative\");\n        for (int i = 0; i < E; i++) {\n            int v = StdRandom.uniform(V);\n            int w = StdRandom.uniform(V);\n            double weight = 0.01*StdRandom.uniform(100);\n            DirectedEdge e = new DirectedEdge(v, w, weight);\n            addEdge(e);\n        }\n    }\n\n    public EdgeWeightedDigraph(In in){\n        this(in.readInt());\n        int E = in.readInt();\n        if (E < 0) throw new IllegalArgumentException(\"Number of edges must be nonnegative\");\n        for(int i=0;i<E;i++){\n            int v = in.readInt();\n            int w=in.readInt();\n            valiadteVertex(v);\n            valiadteVertex(w);\n            double weight = in.readDouble();\n            addEdge(new DirectedEdge(v,w,weight));\n        }\n    }\n\n    public EdgeWeightedDigraph(EdgeWeightedDigraph G){\n        this(G.V());\n        this.E=G.E();\n        for(int v=0;v<G.V();v++)\n            this.indegree[v]=G.indegree(v);\n        for(int v=0;v<G.V();v++){\n            Stack<DirectedEdge> reverse = new Stack<DirectedEdge>();\n            for(DirectedEdge e:G.adj[v])\n                reverse.push(e);\n            for(DirectedEdge e:reverse)\n                adj[v].add(e);    \n        }\n    }\n\n    public int V(){\n        return V;\n    }\n\n    public int E(){\n        return E;\n    }\n    // 添加边\n    public void addEdge(DirectedEdge e){\n        int v = e.from();\n        int w=e.to();\n        valiadteVertex(v);\n        valiadteVertex(w);\n        adj[v].add(e);\n        indegree[w]++;\n        E++;\n    }\n\n    public void valiadteVertex(int v){\n        if(v<0||v>=V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    public Iterable<DirectedEdge> adj(int v){\n        valiadteVertex(v);\n        return adj[v];\n    }\n    // 出度\n    public int outdegree(int v){\n        valiadteVertex(v);\n        return adj[v].size();\n    }\n    // 入度\n    public int indegree(int v){\n        valiadteVertex(v);\n        return indegree[v];\n    }\n    \n    public Iterable<DirectedEdge> edges(){\n        Bag<DirectedEdge> list = new Bag<DirectedEdge>();\n        for(int v=0;v<V;v++){\n            for(DirectedEdge e:adj[v]){\n                list.add(e);\n            }\n        }\n        return list;\n    }\n\n    public String toString(){\n        StringBuilder s = new StringBuilder();\n        s.append(V+\" \"+E+NEWLINE);\n        for(int v=0;v<V;v++){\n            s.append(v+\": \");\n            for(DirectedEdge e:adj[v])\n                s.append(e+\" \");\n            s.append(NEWLINE);\n        }\n        return s.toString();\n    }\n}\n```\n\n\n而最短路径的数据结构就比较简单了。\n最短路径中的边：一个以顶点为索引的DirectedEdge对象的父链接数组edgeTo[]，edgeTo[v]表示v到它父结点的边。\n最短路径的距离：一个由顶点为索引的distTo数组，distTo[v]表示起点到顶点v的距离。\n\n而要找到加权有向图中的最短路径，是基于一个叫「放松」的基本操作。\n一开始，我们假设加权有向图中的顶点到起点的距离：起点为0，其他顶点到起点的距离都是无限远的。\n并且我们将顶点到起点的路径存储在edgeTo中，而距离存储在distTo中，随着算法的进行，包括「放松」的操作，\n路径和距离信息都会得到更新。\n\n而所谓「放松」操作：\n假设有向图中的有三个点，分别是起点s，顶点v，顶点w。倘若s可以到达v，也可以到达w，\n那么distTo[w]即为s到w的距离，若v也可以到达w且v-w的边为e，\n放松v-w边：即检查s到w的最短路径，是否先从s到v，再由v到w，\n若不是，即distTo[v]+e.weight()>=distTo[w]，则称边e失效忽略这条边，\n若是，即distTo[v]+e.weight()<distTo[w]，则更新distTo[w]=distTo[v]+e.weight()。\n\n判断路径是否是最短路径的全局条件与放松一条边时所检测的局部条件是等价的。\n\nDijkstraSP算法的实现如下：\n构造方法中的索引优先队列会先插入打算计算最短路径的起点s，\n1.然后将优先队列中距离起点最短的顶点删除，\n2.再依次放松这个顶点发出的所有边，将其可达的顶点的相关信息存入distTo和edgeTo数组中，\n若该可达顶点不在优先队列中则将其加入，否则只更新相关信息。\n重复执行步骤 1, 2，直至优先队列为空。\n\nJava代码实现：\n\n```java\n// 有向图单点最短路径\nimport java.util.Stack;\n\npublic class DijkstraSP {\n    private double[] distTo;\n    private DirectedEdge[] edgeTo;\n    private IndexMinPQ<Double> pq;\n\n    public DijkstraSP(EdgeWeightedDigraph G, int s) {\n        for (DirectedEdge e : G.edges()) {// 不包含负权重边\n            if (e.weight() < 0)\n                throw new IllegalArgumentException(\"edge \" + e + \" has negative weight\");\n        }\n        distTo = new double[G.V()];\n        edgeTo = new DirectedEdge[G.V()];\n        \n        validateVertex(s);\n\n        for (int v = 0; v < G.V(); v++) {\n            distTo[v] = Double.POSITIVE_INFINITY;// 除起点外 图中其他的点距离起点的距离都是无限远\n        }\n        distTo[s] = 0;\n\n        pq = new IndexMinPQ<Double>(G.V());\n        pq.insert(s, distTo[s]);\n        while (!pq.isEmpty()) {\n            int v = pq.delMin();\n            for (DirectedEdge e : G.adj(v)) {\n                relax(e);// 对v的邻接表内的每条边都进行放松\n            }\n        }\n\n         assert check(G, s);\n    }\n\n    \n    private void relax(DirectedEdge e) {\n        int v = e.from(), w = e.to();\n        if (distTo[w] > distTo[v] + e.weight()) {// 若从起点s到w的距离大于从s-v-s路径的权重 则更新数据\n            distTo[w] = distTo[v] + e.weight();\n            edgeTo[w] = e;\n            if (pq.contains(w))// 若优先队列中已包含w顶点则修改s到w的distTo[s]\n                pq.decreaseKey(w, distTo[w]);\n            else\n                pq.insert(w, distTo[w]);// 若不在优先队列中则添加进去\n        }\n    }\n\n    public double distTo(int v) {\n        validateVertex(v);\n        return distTo(v);\n    }\n\n    public boolean hasPathTo(int v) {\n        validateVertex(v);\n        return distTo[v] < Double.POSITIVE_INFINITY;\n    }\n\n    public Iterable<DirectedEdge> pathTo(int v) {\n        validateVertex(v);\n        if (!hasPathTo(v))\n            return null;\n        Stack<DirectedEdge> path = new Stack<DirectedEdge>();\n        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {\n            path.push(e);\n        }\n        return path;\n    }\n\n    \n    private boolean check(EdgeWeightedDigraph G, int s) {\n\n        // 负权重边检查\n        for (DirectedEdge e : G.edges()) {\n            if (e.weight() < 0) {\n                System.err.println(\"negative edge weight detected\");\n                return false;\n            }\n        }\n\n        // check that distTo[v] and edgeTo[v] are consistent\n        if (distTo[s] != 0.0 || edgeTo[s] != null) {\n            System.err.println(\"distTo[s] and edgeTo[s] inconsistent\");\n            return false;\n        }\n        for (int v = 0; v < G.V(); v++) {\n            if (v == s) continue;\n            if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {\n                System.err.println(\"distTo[] and edgeTo[] inconsistent\");\n                return false;\n            }\n        }\n\n        // check that all edges e = v->w satisfy distTo[w] <= distTo[v] + e.weight()\n        for (int v = 0; v < G.V(); v++) {\n            for (DirectedEdge e : G.adj(v)) {\n                int w = e.to();\n                if (distTo[v] + e.weight() < distTo[w]) {\n                    System.err.println(\"edge \" + e + \" not relaxed\");\n                    return false;\n                }\n            }\n        }\n\n        // check that all edges e = v->w on SPT satisfy distTo[w] == distTo[v] + e.weight()\n        for (int w = 0; w < G.V(); w++) {\n            if (edgeTo[w] == null) continue;\n            DirectedEdge e = edgeTo[w];\n            int v = e.from();\n            if (w != e.to()) return false;\n            if (distTo[v] + e.weight() != distTo[w]) {\n                System.err.println(\"edge \" + e + \" on shortest path not tight\");\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void validateVertex(int v){\n        int V =distTo.length;\n        if(v<0||v>=V){\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n        }\n    }\n}\n```\n","tags":["算法"]},{"title":"Kruskal算法","url":"%2F2019%2F10%2F15%2FKruskal%E7%AE%97%E6%B3%95%2F","content":"\n第二种计算最小生成树的算法是Kruskal算法。\n\n这个算法的主要思想是按照边的权重顺序处理它们，\n将边加入最小生成树中，并且新加入的边与已加入的边不会形成环，直至达到V-1条边结束。\n\n算法一开始会将图中所有的边加入到优先队列中，\n从中找到权重最小的边，然后将之加入到最小生成树中，\n在边不断的加入到最小生成树的过程中，可能会出现环，\nAglorithms中Kruskal算法的实现对此的处理方式是：通过一个UF类来判断即将加入最小生成树的边的两个顶点是否在同一个连通分量中。\n也就是说假如两个顶点已经在同一个连通分量中了，即两个顶点之间已经有边连接且在最小生成树中，此时即将加入的这条边本身已将这两个顶点连接在一起，若将它加入到最小生成树中，则构成了环。\nUF类本身很简单。\n其Java实现如下：\n整个类一开始初始化会将图中的每个顶点设置为单点树。\n类中函数包括：判断两点是否连接的、找出顶点所在连通分量(树)的、连接两颗树的。\n\n```java\n\npublic class UF {\n\n    private int[] parent;  // 顶点所在连通分量的标识符\n    private byte[] rank;   // 顶点的连通分量中的位置\n    private int count;     // 顶点数量\n\n    public UF(int n) {\n        if (n < 0) throw new IllegalArgumentException();\n        count = n;\n        parent = new int[n];\n        rank = new byte[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    public int find(int p) {// 找到p所在的连通分量标识符\n        validate(p);\n        while (p != parent[p]) { // 在和别的触点连通的情况下\n            parent[p] = parent[parent[p]];    \n            p = parent[p];\n        } \n        return p;\n    }\n\n    \n    public int count() {\n        return count;\n    }\n  \n    \n    public boolean connected(int p, int q) {// 判断两点之间是否连接 或在同一个分量中\n        return find(p) == find(q);\n    }\n  \n    \n    public void union(int p, int q) {// 添加一条连接\n        int rootP = find(p);\n        int rootQ = find(q);\n        if (rootP == rootQ) return;\n\n        \n        if      (rank[rootP] < rank[rootQ]) parent[rootP] = rootQ;\n        else if (rank[rootP] > rank[rootQ]) parent[rootQ] = rootP;\n        else {\n            parent[rootQ] = rootP;\n            rank[rootP]++;\n        }\n        count--;\n    }\n\n\n    private void validate(int p) {\n        int n = parent.length;\n        if (p < 0 || p >= n) {\n            throw new IllegalArgumentException(\"index \" + p + \" is not between 0 and \" + (n-1));  \n        }\n    }\n}\n```\n\nKruskal算法的实现如下：\n\n```java\npublic class KruskalMST {\n    private static final double FLOATING_POINT_EPSILON = 1E-12;\n\n    private double weight;\n    private Queue<Edge> mst = new Queue<Edge>();\n\n    public KruskalMST(EdgeWeightedGraph G) {\n        MinPQ<Edge> pq = new MinPQ<Edge>();\n        for (Edge e : G.edges()) {\n            pq.insert(e);// 将图中的所有边加入到优先队列中\n        }\n\n        UF uf = new UF(G.V());\n        while (!pq.isEmpty() && mst.size() < G.V() - 1) {\n            Edge e = pq.delMin();\n            int v = e.either();\n            int w = e.other(v);\n            if (!uf.connected(v, w)) {// 在uf对象中，v、w两点是未连接的分量\n                uf.union(v, w);// 连接vw\n                mst.enqueue(e);// 将边加到最小生成树中\n                weight += weight;\n            }\n        }\n\n        assert check(G);\n\n    }\n\n    public Iterable<Edge> edges() {\n        return mst;\n    }\n\n    public double weight() {\n        return weight;\n    }\n\n    private boolean check(EdgeWeightedGraph G) {\n        double total = 0.0;\n        for (Edge e : edges()) {\n            total += e.weight();\n        }\n\n        if (Math.abs(total - weight()) > FLOATING_POINT_EPSILON) {\n            System.err.printf(\"Weight of edges does not equal weight(): %f vs. %f\\n\", total, weight());\n            return false;\n        }\n\n        UF uf = new UF(G.V());\n        for (Edge e : edges()) {\n            int v = e.either(), w = e.other(v);\n            if (uf.connected(v, w)) {\n                System.err.println(\"Not a forest\");\n                return false;\n            }\n            uf.union(v, w);\n        }\n        for (Edge e : G.edges()) {\n            int v = e.either(), w = e.other(v);\n            if (!uf.connected(v, w)) {\n                System.err.println(\"Not a spanning forest\");\n                return false;\n            }\n        }\n\n        for (Edge e : edges()) {\n\n            // all edges in MST except e\n            uf = new UF(G.V());\n            for (Edge f : mst) {\n                int x = f.either(), y = f.other(x);\n                if (f != e)\n                    uf.union(x, y);\n            }\n\n            // check that e is min weight edge in crossing cut\n            for (Edge f : G.edges()) {\n                int x = f.either(), y = f.other(x);\n                if (!uf.connected(x, y)) {\n                    if (f.weight() < e.weight()) {\n                        System.err.println(\"Edge \" + f + \" violates cut optimality conditions\");\n                        return false;\n                    }\n                }\n            }\n\n        }\n        return true;\n    }\n}\n```\n","tags":["算法"]},{"title":"Prim算法的即时实现","url":"%2F2019%2F10%2F15%2FPrim%E7%AE%97%E6%B3%95%E7%9A%84%E5%8D%B3%E6%97%B6%E5%AE%9E%E7%8E%B0%2F","content":"\n在Prim算法的延迟实现中，生成最小生成树的过程中，优先队列中保存有失效的边。\n改进延迟实现，可以尝试从优先队列中删除失效的边，只保留有树中的点和非树中的点之间的横切边。\n在Prim算法的即时实现中，我们并不这么做。\n我们将新顶点加入到最小生成树时，其余非树中的顶点到最小生成树的距离只可能变小。\n我们并不需要在优先队列中保留非树中的顶点到最小生成树的所有横切边，只保留权重最小的那条边即可。\n在某个新顶点加入到最小生成树时，检查是否需要更新这条边即可。\n在Prim算法的即时实现中：\nedgeTo[]保存的是非树中顶点到最小生成树距离最短的边。\ndistTo[]则保存的是这条边的权重。\n\n其构造函数会遍历图中的顶点，将起点加入到最小生成树时，会将起点的邻接链表中的边都加入到索引优先队列中，因为从上面的内容来看，这些邻接边目前是那些非树顶点到树距离最小的边，之后随着不断的将新顶点加入到最小生成树中，需要不断的更新索引优先队列的数据，只保留非树顶点到树距离最小的边，直至将图中的顶点遍历完毕。\n\n下面是其Java实现：\n\n```java\npublic class PrimMST {\n    private static final double FLOATING_POINT_EPSILON = 1E-12;\n\n    private Edge[] edgeTo;// 距离树最短的边\n    private double[] distTo;// 距离树最短的边的权重\n    private boolean[] marked;// 标记\n    private IndexMinPQ<Double> pq;// 保存有效的横切边\n\n    public PrimMST(EdgeWeightedGraph G) {\n        edgeTo = new Edge[G.V()];\n        distTo = new double[G.V()];\n        marked = new boolean[G.V()];\n        pq = new IndexMinPQ<Double>(G.V());\n\n        for (int v = 0; v < G.V(); v++) {\n            distTo[v] = Double.POSITIVE_INFINITY;// 未加入最小生成树前初始化所有顶点到最小生成树的距离为无限远\n        }\n\n        for (int v = 0; v < G.V(); v++) {// 遍历顶点\n            if (!marked[v])\n                prim(G, v);\n        }\n\n        assert check(G);\n    }\n\n    private void prim(EdgeWeightedGraph G, int s) {\n        distTo[s] = 0.0;// 加入MST的顶点距离MST的距离必然为0\n        pq.insert(s, distTo[s]);\n        while (!pq.isEmpty()) {\n            int v = pq.delMin();\n            scan(G, v);\n        }\n    }\n\n    // 将顶点v加入最小生成树中 并更新数据\n    private void scan(EdgeWeightedGraph G, int v) {\n        marked[v] = true;// 标记\n        for (Edge e : G.adj(v)) {\n            int w = e.other(v);\n            if (marked[w])\n                continue;\n            if (e.weight() < distTo[w]) {\n                distTo[w] = e.weight();\n                edgeTo[w] = e;\n                if (pq.contains(w))\n                    pq.decreaseKey(w, distTo[w]);\n                else\n                    pq.insert(w, distTo[w]);\n            }\n        }\n    }\n\n    public Iterable<Edge> edges() {\n        Queue<Edge> mst = new Queue<Edge>();\n        for (int v = 0; v < edgeTo.length; v++) {\n            Edge e = edgeTo[v];\n            if (e != null) {\n                mst.enqueue(e);\n            }\n        }\n        return mst;\n    }\n\n    public double weight() {\n        double weight = 0.0;\n        for (Edge e : edges()) {\n            weight += e.weight();\n        }\n        return weight;\n    }\n\n    private boolean check(EdgeWeightedGraph G) {\n\n        // 检查权重\n        double totalWeight = 0.0;\n        for (Edge e : edges()) {\n            totalWeight += e.weight();\n        }\n        if (Math.abs(totalWeight - weight()) > FLOATING_POINT_EPSILON) {\n            System.err.printf(\"Weight of edges does not equal weight(): %f vs. %f\\n\", totalWeight, weight());\n            return false;\n        }\n\n        // 检查是否是环\n        UF uf = new UF(G.V());\n        for (Edge e : edges()) {\n            int v = e.either(), w = e.other(v);\n            if (uf.connected(v, w)) {\n                System.err.println(\"Not a forest\");\n                return false;\n            }\n            uf.union(v, w);\n        }\n\n        // 检查是否是森林\n        for (Edge e : G.edges()) {\n            int v = e.either(), w = e.other(v);\n            if (!uf.connected(v, w)) {\n                System.err.println(\"Not a spanning forest\");\n                return false;\n            }\n        }\n\n        // 检查是否是最小生成森林\n        for (Edge e : edges()) {\n            uf = new UF(G.V());\n            for (Edge f : edges()) {\n                int x = f.either(), y = f.other(x);\n                if (f != e)\n                    uf.union(x, y);\n            }\n\n            for (Edge f : G.edges()) {\n                int x = f.either(), y = f.other(x);\n                if (!uf.connected(x, y)) {\n                    if (f.weight() < e.weight()) {\n                        System.err.println(\"Edge \" + f + \" violates cut optimality conditions\");\n                        return false;\n                    }\n                }\n            }\n\n        }\n        return true;\n    }\n}\n```\n\n","tags":["算法"]},{"title":"Prim算法的延迟实现","url":"%2F2019%2F10%2F15%2FPrim%E7%AE%97%E6%B3%95%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%AE%9E%E7%8E%B0%2F","content":"\n上篇博文的内容涉及到的是最小生成树的理论部分。即：切分定理以及加权图和加权边的数据结构。\n回顾一下切分定理，它的内容是：\n**在一幅加权图中，给定任意的切分，它的横切边中权重最小的边必然属于图的最小生成树。**\n而所谓的切分，则是将图中的顶点分成两个非空不重叠的集合，横切边是连接两个不同集合内的顶点的边。\n能够找到任意加权图的算法这里介绍了两种：一种是Prim算法，一种是Kruskal算法。\nPrim算法的实现又分两种，一种是延迟实现，一种是即时实现。\n区别在于对新加入最小生成树的顶点与树内其他顶点之间的边是否及时删除上。\n\n先说说Prim算法的延迟实现。\n首先其实现切分的方式是在构造方法中遍历图中的顶点，\n将图中的顶点分成已标记的顶点和未标记的顶点两个非空集合。\n然后将已标记的顶点中所有连接这个顶点和未被标记的顶点的边加入到优先队列中，\n标记其中权重最小的边，加入到最小生成树中，并将相关的顶点加入到最小生成树中。\n\n因为优先队列中的那些并不是当前被遍历到的顶点的横切边没有被删除，\n即便正在被遍历的顶点的横切边中最小权重边在优先队列中不是最小的，\n也应当忽略优先队列中的那些失效的横切边即便它们权重更小，而选择正在被遍历的顶点的最小权重边。\n相应的解决办法是，因为那些没有被删除的失效边两端的顶点均在最小生成树内，\n则必然会被标记，所以一旦检查到其两端顶点被标记过则直接忽略它，\n继续找优先队列中的下一个最小权重边。\n\n以上是延迟实现的一些关键地方。下面是其Java实现：\n\n```java\npublic class LazyPrimMST {\n    private static final double FLOATING_POINT_EPSILON = 1E-12;\n\n    private double weight;// 最小生成树的权重大小\n    private Queue<Edge> mst;// 最小生成的边\n    private boolean[] marked;// 最小生成树的顶点\n    private MinPQ<Edge> pq;// 横切边\n\n    public LazyPrimMST(EdgeWeightedGraph G) {\n        mst = new Queue<Edge>();\n        pq = new MinPQ<Edge>();\n        marked = new boolean[G.V()];\n        for (int v = 0; v < G.V(); v++) {\n            if (!marked[v])\n                prim(G, v);\n        }\n        assert check(G);\n    }\n\n    private void prim(EdgeWeightedGraph G, int s) {\n        scan(G, s);\n        while (!pq.isEmpty()) {\n            Edge e = pq.delMin();\n            int v = e.either(), w = e.other(v);\n            assert marked[v]||marked[w];\n            if (marked[v] && marked[w]) // pq中的横切边若失效了(权重并不是最小的) 即跳过\n                continue;\n            mst.enqueue(e);// 添加最小权重横切边到最小生成树中\n            weight += e.weight();// 更新最小生成树的权重\n            if (!marked[v])// 标记顶点v或者w，即将顶点加入到最小生成树中\n                scan(G, v);\n            if (!marked[w])\n                scan(G, w);\n        }\n    }\n\n    // 标记顶点v 并将所有连接顶点v和未标记顶点的边加入pq中\n    private void scan(EdgeWeightedGraph G, int v) {\n        assert !marked[v];\n        marked[v] = true;\n        for (Edge e : G.adj(v)) {\n            if (!marked[e.other(v)])\n                pq.insert(e);\n        }\n    }\n\n    public Iterable<Edge> edges() {\n        return mst;\n    }\n\n    public double weight() {\n        return weight;\n    }\n\n    private boolean check(EdgeWeightedGraph G) {\n\n        double totalWeight = 0.0;\n        for (Edge e : edges()) {\n            totalWeight += e.weight();\n        }\n        if (Math.abs(totalWeight - weight()) > FLOATING_POINT_EPSILON) {\n            System.err.printf(\"Weight of edges does not equal weight(): %f vs. %f\\n\", totalWeight, weight());\n            return false;\n        }\n\n        UF uf = new UF(G.V());\n        for (Edge e : edges()) {\n            int v = e.either(), w = e.other(v);\n            if (uf.connected(v, w)) {\n                System.err.println(\"Not a forest\");\n                return false;\n            }\n            uf.union(v, w);\n        }\n\n        for (Edge e : G.edges()) {\n            int v = e.either(), w = e.other(v);\n            if (!uf.connected(v, w)) {\n                System.err.println(\"Not a spanning forest\");\n                return false;\n            }\n        }\n\n        for (Edge e : edges()) {\n\n            // all edges in MST except e\n            uf = new UF(G.V());\n            for (Edge f : mst) {\n                int x = f.either(), y = f.other(x);\n                if (f != e)\n                    uf.union(x, y);\n            }\n\n            // check that e is min weight edge in crossing cut\n            for (Edge f : G.edges()) {\n                int x = f.either(), y = f.other(x);\n                if (!uf.connected(x, y)) {\n                    if (f.weight() < e.weight()) {\n                        System.err.println(\"Edge \" + f + \" violates cut optimality conditions\");\n                        return false;\n                    }\n                }\n            }\n\n        }\n\n        return true;\n    }\n}\n```\n\n","tags":["算法"]},{"title":"最小生成树","url":"%2F2019%2F10%2F15%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F","content":"\n图的分类中，有一类叫加权图，即图的每条边关联一个权值或是成本。\n这类图在实际生活中的应用很多：电路、航空、电力分配、图像分析等。\n图的生成树，表示的一颗含有图中所有顶点的无环连通子图。\n而加权图中的最小生成树，则表示这棵树在所有生成树中所有的边的权重加起来是最小的。\n\nAlgorithms中计算最小生成树，遵守以下约定：\n只考虑连通图；\n边的权重不一定表示距离；\n边的权重可能是0或者负的；\n所有边的权重都不相同。\n\n树是无环连通图，则意味着：\n树是连通的；\n树中不存在环；\n树中添加任意一条边都会产生一条环；\n树中删除任意一条边都会使它不再连通；\n树中任意一对顶点之间都仅存一条简单路径。\n\n其中添加一条边就会产生一个新的环和删除任意一条边将会得到两棵树，\n是证明最小生成树的一条性质的基础，而这个基本性质则是最小生成树算法的基础。\n\n定义：图的一种切分是将图中的顶点分成两个非空不重叠的集合。横切边是一条连接两个属于不同集合的顶点的边。\n切分定理：一幅加权图中，给定任意的切分，它的横切边中权重最小的边必然属于图的最小生成树。\n切分定理是解决最小生成树问题的所有算法的基础，属于贪心算法的特殊情况。使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树的所有边。\n\n最小生成树的贪心算法：会找到加权连通图中的最小生成树，并将它的边全标记为黑色。其过程是在V个顶点的加权连通图中，初始状态下将所有边设为灰色，找到一种切分，它产生的横切边均不为黑色，将它权重最小的横切边设为黑色，反复，直至标记了V-1条黑色边为止。\n\n加权无向图的数据类型有两种：即Edge--加权边和EdgeWeightedGraph--加权图；\n以下是这两种数据类的Java实现：\n\n```java\n// 加权边\n\npublic class Edge implements Comparable<Edge> {\n    private final int v;\n    private final int w;\n    private final double weight;\n\n    public Edge(int v, int w, double weight) {\n        if (v < 0)\n            throw new IllegalArgumentException(\"vertex index must be a nonnegative integer\");\n        if (w < 0)\n            throw new IllegalArgumentException(\"vertex index must be a nonnegative integer\");\n        if (Double.isNaN(weight))\n            throw new IllegalArgumentException(\"Weight is NaN\");\n        this.v = v;\n        this.w = w;\n        this.weight = weight;\n    }\n\n    public double weight() {\n        return weight;\n    }\n\n    public int either() {\n        return v;\n    }\n\n    public int other(int vertex) {\n        if (vertex == v)\n            return w;\n        else if (vertex == w)\n            return v;\n        else\n            throw new IllegalArgumentException(\"Illegal endpoint\");\n    }\n\n    public int compareTo(Edge that) {\n        return Double.compare(this.weight, that.weight);\n    }\n\n    public String toString() {\n        return String.format(\"%d-%d %.5f\", v, w, weight);\n    }\n\n}\n```\n\n```java\n// 加权图\nimport java.util.Stack;\n\npublic class EdgeWeightedGraph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n    private final int V;\n    private int E;\n    private Bag<Edge>[] adj;\n\n    public EdgeWeightedGraph(int V) {\n        if (V < 0)\n            throw new IllegalArgumentException(\"Number of vertices must be nonnegative\");\n        this.V = V;\n        this.E = 0;\n        adj = (Bag<Edge>[]) new Bag[V];\n        for (int v = 0; v < V; v++) {\n            adj[v] = new Bag<Edge>();\n        }\n    }\n\n    public EdgeWeightedGraph(int V, int E) {\n        this(V);\n        if (E < 0)\n            throw new IllegalArgumentException(\"Number of vertices must be nonnegative\");\n        for (int i = 0; i < E; i++) {\n            int v = StdRandom.uniform(V);\n            int w = StdRandom.uniform(V);\n            double weight = Math.round(100 * StdRandom.uniform()) / 100.0;\n            Edge e = new Edge(v, w, weight);\n            addEdge(e);\n        }\n    }\n\n    public EdgeWeightedGraph(In in) {\n        this(in.readInt());\n        int E = in.readInt();\n        if (E < 0)\n            throw new IllegalArgumentException(\"Number of edges must be nonnegative\");\n        for (int i = 0; i < E; i++) {\n            int v = in.readInt();\n            int w = in.readInt();\n            validateVertex(v);\n            validateVertex(w);\n            double weight = in.readDouble();\n            Edge e = new Edge(v, w, weight);\n            addEdge(e);\n        }\n    }\n\n    public EdgeWeightedGraph(EdgeWeightedGraph G) {\n        this(G.V());\n        this.E = G.E();\n        for (int v = 0; v < G.V(); v++) {\n            Stack<Edge> reverse = new Stack<Edge>();\n            for (Edge e : G.adj[v]) {\n                reverse.push(e);\n            }\n            for (Edge e : reverse) {\n                adj[v].add(e);\n            }\n        }\n    }\n\n    public int V() {\n        return V;\n    }\n\n    public int E() {\n        return E;\n    }\n\n    private void validateVertex(int v) {\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1));\n    }\n\n    public void addEdge(Edge e) {\n        int v = e.either();\n        int w = e.other(v);\n        validateVertex(v);\n        validateVertex(w);\n        adj[v].add(e);\n        adj[w].add(e);\n        E++;\n    }\n\n    public Iterable<Edge> adj(int v) {\n        validateVertex(v);\n        return adj[v];\n    }\n\n    public int degree(int v) {\n        validateVertex(v);\n        return adj[v].size();\n    }\n\n    public Iterable<Edge> edges() {\n        Bag<Edge> list = new Bag<Edge>();\n        for (int v = 0; v < V; v++) {\n            int selfLoops = 0;\n            for (Edge e : adj(v)) {\n                if (e.other(v) > v) {\n                    list.add(e);\n                } else if (e.other(v) == v) {\n                    if (selfLoops % 2 == 0)\n                        list.add(e);\n                    selfLoops++;\n                }\n            }\n        }\n        return list;\n    }\n\n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        s.append(V + \" \" + E + NEWLINE);\n        for (int v = 0; v < V; v++) {\n            s.append(v + \": \");\n            for (Edge e : adj[v]) {\n                s.append(e + \" \");\n            }\n            s.append(NEWLINE);\n        }\n        return s.toString();\n    }\n}\n```\n\n","tags":["算法"]},{"title":"计算强连通性的Kosaraju算法","url":"%2F2019%2F10%2F15%2F%E8%AE%A1%E7%AE%97%E5%BC%BA%E8%BF%9E%E9%80%9A%E6%80%A7%E7%9A%84Kosaraju%E7%AE%97%E6%B3%95%2F","content":"\n在无向图中，因为边没有方向，所以假设v、w两点是连通的，既可以从v到达w，也可以从w到达v。\n但在有向图中，因为边有方向，假设v、w两点是连通的，即存在从v到达w的有向路径，但从w到达v的有向路径可能存在也可能不存在。\n有向图中，如果两点是相互可达的，则称这两个点是强连通的。\n当两个点是强连通的当且仅当它们都在一个普通的有向环中。\n在无向图中计算连通分量只是深度优先搜索的一个简单应用，在有向图中深度优先搜索也可以用来计算强连通分量。这里要用到之前提到的DepthFirstOrder类，并且完成以下的任务。\n① 将给定的有向图G，利用DepthFirstOrder类计算其反向图的逆后序排列。\n② 在G中进行深度优先搜索，但以刚才计算得到的逆后序排列为顺序来访问未被标记的顶点。\n③ 在构造函数中，所有在同一个递归dfs调用中被访问到的顶点都在同一个强连通分量中，均会被识别出来。\n以下是Java的实现：\n\n```java\n// 计算强连通分量\npublic class KosarajuSharirSCC {\n    private boolean[] marked;// 标记\n    private int[] id;// 顶点和强连通分量标识符关联\n    private int count;// 强连通分量的编号\n\n    public KosarajuSharirSCC(Digraph G) {\n        DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());// 反向图的深度优先搜索排序\n        marked = new boolean[G.V()];\n        id = new int[G.V()];\n        for (int v : dfs.reversePost()) {// 访问顺序是反向图的逆后序排列\n            if (!marked[v]) {\n                dfs(G, v);\n                count++;\n            }\n        }\n\n        assert check(G);\n    }\n\n    private void dfs(Digraph G, int v) {\n        marked[v] = true;\n        id[v] = count;\n        for (int w : G.adj(v)) {\n            if (!marked[w])\n                dfs(G, w);\n        }\n    }\n\n    public int count() {\n        return count;\n    }\n\n    public boolean stronglyConnected(int v, int w) {\n        validateVertex(v);\n        validateVertex(w);\n        return id[v] == id[w];\n    }\n\n    public int id(int v) {\n        validateVertex(v);\n        return id[v];\n    }\n\n    private boolean check(Digraph G) {\n        TransitiveClosure tc = new TransitiveClosure(G);\n        for (int v = 0; v < G.V(); v++) {\n            for (int w = 0; w < G.V(); w++) {\n                if (stronglyConnected(v, w) != tc.reachable(v, w) && tc.reachable(w, v))\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1));\n    }\n}\n```\n\nKosaraju算法实现容易，但难以理解。\n它的理论依据是：使用深度优先搜索查找给定的有向图G的反向图，根据由此得到的所有顶点的逆后序再次用深度优先搜索处理有向图G，其构造函数中的每一次递归调用所标记的顶点都在同一个强连通分量中。\n这个理论，证明起来也不是很难。\n首先，用反证法证明「每个与s强连通的顶点v都会在构造函数的dfs(G,s)中被访问到」。\n假设有一个与s强连通的顶点v不会在构造函数调用的dfs(G,s)中被访问到。因为存在s到达v的路径，则v在之前肯定被标记过了。又因为也存在v到达s的路径，则s在dfs(G,v)的调用中被标记过，所以构造函数不会调用dfs(G,s)的。矛盾。\n其次，要证明「构造函数调用的dfs(G,s)所到达的任意顶点v都必然是和s强连通的」。\n假设v是dfs(G,s)到达的某个顶点，那么G中必然存在一条s到达v的路径，现在只需要证明G中也存在一条从v到达s的路径即可。这也等价于在G的反向图中找到一条从s到达v的路径。\n按照逆后序进行的深度优先搜索意味着，在G的反向图中进行的深度优先搜索中，dfs(G,v)必然在dfs(G,s)之前就已经结束了。这样dfs(G,v)的调用就只会出现两种情况：\n调用在dfs(G,s)的调用之前，也在dfs(G,s)的调用之前结束。\n调用在dfs(G,s)的调用之后，也在dfs(G,s)的结束之前结束。\n第一种情况不存在，因为G的反向图中存在一条v到达s的路径。\n第二种情况则说明G的反向图中存在一条从s到达v的路径。\n\n","tags":["算法"]},{"title":"有向图中基于深度优先搜索的顶点排序&拓扑排序","url":"%2F2019%2F10%2F15%2F%E6%9C%89%E5%90%91%E5%9B%BE%E4%B8%AD%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%9A%84%E9%A1%B6%E7%82%B9%E6%8E%92%E5%BA%8F-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F","content":"\n深度优先搜索中，图中的每个顶点只会被访问一次。\n那么将dfs的参数顶点保存在一个数据结构中，遍历这个数据结构实际上能访问到图中的所有顶点。\n遍历的顺序取决于这个数据结构以及是在递归之前还是之后进行保存的。\n典型的应用中，最为让人感兴趣的有3中排列顺序。\n* 前序：递归调用之前将顶点加入队列。\n* 后序：递归调用之后将顶点加入队列。\n* 逆后序：递归调用之后将顶点压入栈。\n本质上来说，前序是dfs的调用顶点的顺序。后序则是顶点遍历完成的顺序。\n![depth-first-orders](https://isshl.me/img/depth-first-orders.png)\n以下为Java的实现：\n\n```java\n// 有向图中基于深度优先搜索的顶点排序\n\nimport java.util.Stack;\n\npublic class DepthFirstOrder{\n    private boolean[] marked;// 标记\n    private int[] pre;// 前序中顶点在队列中的编号\n    private int[] post;// 后序中顶点在队列中的编号\n    private Queue<Integer> preorder;// 前序队列\n    private Queue<Integer> postorder;// 后序队列\n    private int preCounter;// 前序队列中顶点的数量\n    private int postCounter;// 后序队列中顶点的数量\n    \n    public DepthFirstOrder(Digraph G){\n        pre = new int[G.V()];\n        post = new int[G.V()];\n        postorder = new Queue<Integer>();\n        preorder = new Queue<Integer>();\n        marked = new boolean[G.V()];\n        for(int v=0;v<G.V();v++){\n            if(!marked[v]) dfs(G, v);\n        }\n        assert check();\n    }\n\n    private void dfs(Digraph G,int v){\n        marked[v]=true;// 标记\n        pre[v]=preCounter++;// 前序中顶点在队列中的编号\n        preorder.enqueue(v);// 添加到前序队列中\n        for(int w:G.adj(v)){\n            if(!marked[w])\n            dfs(G, w);\n        }\n        postorder.enqueue(v);// 添加到后序队列中\n        post[v]=postCounter++;// 后序中顶点在队列中的编号\n    }\n\n    public DepthFirstOrder(){}// 待更新加权有向图 \n\n    private void dfs(){} // 待更新加权有向图\n\n    // 返回顶点在前序中的编号\n    public int pre(int v){\n        validateVertex(v);\n        return pre[v];\n    }\n\n    // 返回顶点在后序中的编号\n    public int post(int v){\n        validateVertex(v);\n        return post[v];\n    }\n    \n    public Iterable<Integer> pre(){\n        return preorder;\n    }\n\n    public Iterable<Integer> post(){\n        return postorder;\n    }\n\n    public Iterable<Integer> reversePost(){\n        Stack<Integer> reverse = new Stack<Integer>();\n        for(int v:postorder){\n            reverse.push(v);\n        }\n        return reverse;\n    }\n\n    private boolean check(){\n        int r=0;\n        for(int v:post()){\n            if(post(v)!=r){\n                StdOut.println(\"post(v) and post() inconsistent\");\n                return false;\n            }\n            r++;\n        }\n        r=0;\n        for(int v:pre()){\n            if (pre(v) != r) {\n                StdOut.println(\"pre(v) and pre() inconsistent\");\n                return false;\n            }\n            r++;\n        }\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n}\n```\n\n\n拓扑排序：给定一幅有向图，将有所的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素。\n在优先级的调度问题中，排在前面的任务通常是后面任务的前提，或者说优先级更高。\n而拓扑排序则是解决这个问题的关键。那什么样的有向图才能进行拓扑排序呢？\n有向图必须是无环图。\n而上面的有向图基于深度优先搜索的顶点排序，其中的逆后序排列恰好就是拓扑顺序。\n思考一下：深度优先搜索中，最先完成遍历结束的一定是远处的顶点。然后才是近处的顶点，最后是起点。拓扑排序是前面的顶点发出的有向边均指向排在后面的元素。\n![topological-sort](https://isshl.me/img/topological-sort.png)\n以下是Java实现：\n\n```java\n// 拓扑排序\npublic class Topological{\n    private Iterable<Integer> order;\n    private int[] rank;\n\n    public Topological(Digraph G){\n        DirectedCycle finder = new DirectedCycle(G);// 检查有向图中是否存在环\n        if(!finder.hasCycle()){// 没有环就可以构建拓扑排序\n            DepthFirstOrder  dfs = new DepthFirstOrder(G);\n            order = dfs.reversePost();\n            rank = new int[G.V()];\n            int i=0;\n            for(int v:order){\n                rank[v]=i++;\n            }\n        }\n    }\n\n    public Topological(){}// 待更新加权有向图\n\n    public Iterable<Integer> order(){\n        return order;\n    }\n\n    public boolean hasOrder(){\n        return order!=null;\n    }\n\n    public int rank(int v){\n\n        if(hasOrder()) return rank[v];\n        else return -1;\n    }\n\n    private void validateVertex(int v){\n        int V = rank.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n}\n```\n","tags":["算法"]},{"title":"有向图&可达性&有向环","url":"%2F2019%2F10%2F15%2F%E6%9C%89%E5%90%91%E5%9B%BE-%E5%8F%AF%E8%BE%BE%E6%80%A7-%E6%9C%89%E5%90%91%E7%8E%AF%2F","content":"\n什么是有向图？一幅有方向性的图。\n什么有方向？边有方向。即单向的。\n边连接的是什么？边连接的是一对有序的顶点。\n总结：一幅有方向性的图，该图由一组顶点和一组有向边组成，每条有方向的边连接着一对有序的顶点。\n有向图具有的一些性质和无向图类似。以下摘取部分。\n自环就是一条边的起点和终点都是同一个顶点。\n平行边就是两条边同时连接同一对有序顶点。\n入度：表示有多少条边指向顶点。\n出度：表示有多少条边指出顶点。\n有向路径：由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点。\n有向环：是一条有向路径，其起点和终点是相同的顶点，且至少含有一条边。\n路径或者环的长度就是其中的有向边的边数。\n顶点之间可达，表示它们之间至少存在一条有向路径。\n顶点之间是强连接的表示它们之间是相互可达的。\n强连接有向图表示：图中的每个点都是相互可达的。\n下面是Digraph抽象数据类型的Java实现：\n\n```java\nimport java.util.NoSuchElementException;\nimport java.util.Stack;\n\npublic class Digraph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n    private final int V;\n    private int E;\n    private Bag<Integer>[] adj;\n    private int[] indegree;// 入度\n\n    public Digraph(int V) {\n        if (V < 0)\n            throw new IllegalArgumentException(\"Number of vertices in a Digraph must be nonnegative\");\n        this.V = V;\n        this.E = 0;\n        indegree = new int[V];\n        adj = (Bag<Integer>[]) new Bag[V];\n        for (int v = 0; v < V; v++) {\n            adj[v] = new Bag<Integer>();\n        }\n    }\n\n    public Digraph(In in) {\n        try {\n            this.V = in.readInt();\n            if (V < 0)\n                throw new IllegalArgumentException(\"Number of vertices in a Digraph must be nonnegative\");\n            indegree = new int[V];\n            adj = (Bag<Integer>[]) new Bag[V];\n            for (int v = 0; v < V; v++) {\n                adj[v] = new Bag<Integer>();\n            }\n            int E = in.readInt();\n            if (E < 0)\n                throw new IllegalArgumentException(\"number of edges in a Digraph must be nonnegative\");\n            for (int i = 0; i < E; i++) {\n                int v = in.readInt();\n                int w = in.readInt();\n                addEdge(v, w);\n            }\n        } catch (NoSuchElementException e) {\n            throw new IllegalArgumentException(\"invalid input format in Digraph constructor\", e);\n        }\n    }\n\n    public Digraph(Digraph G) {\n        this(G.V());\n        this.E = G.E();\n        for (int v = 0; v < V; v++) {\n            Stack<Integer> reverse = new Stack<Integer>();\n            for (int w : G.adj[v]) {\n                reverse.push(w);\n            }\n            for (int w : reverse) {\n                adj[v].add(w);\n            }\n        }\n    }\n\n    public int V() {\n        return V;\n    }\n\n    public int E() {\n        return E;\n    }\n\n    public void validateVertex(int v) {\n        if (v < 0 || v >= V) {\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not betweent 0 and \" + (V - 1));\n        }\n    }\n\n    public void addEdge(int v, int w) {\n        validateVertex(v);\n        validateVertex(w);\n        adj[v].add(w);\n        indegree[w]++;\n        E++;\n    }\n\n    public Iterable<Integer> adj(int v) {\n        validateVertex(v);\n        return adj[v];\n    }\n\n    public int outdegree(int v) {\n        validateVertex(v);\n        return adj[v].size();\n    }\n\n    public int indegree(int v) {\n        validateVertex(v);\n        return indegree(v);\n    }\n\n    //\n    public Digraph reverse() {\n        Digraph reverse = new Digraph(V);\n        for (int v = 0; v < V; v++) {\n            for (int w : adj(v)) {\n                reverse.addEdge(w, v);\n            }\n        }\n        return reverse;\n    }\n\n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        s.append(V + \" vertices, \" + E + \" edges \" + NEWLINE);\n        for (int v = 0; v < V; v++) {\n            s.append(String.format(\"%d\", v));\n            for (int w : adj[v]) {\n                s.append(String.format(\"%d \", w));\n            }\n            s.append(NEWLINE);\n        }\n        return s.toString();\n    }\n}\n```\n\n有向图的单点可达性：即是否存在一条从s到达给定顶点v的有向路径？\n解决这个问题通常需要深度优先搜索。\nJava的实现如下：其中也包含了多点可达性，即是否存在一条从集合中的任意顶点到达给定顶点v的有向路径\n\n```java\n// 单点可达性\n// 以标准的深度优先搜索来解决\npublic class DirectedDFS {\n    private boolean[] marked;\n    private int count;// 起点可以达到的顶点数量\n\n    public DirectedDFS(Digraph G, int s) {\n        marked = new boolean[G.V()];\n        validateVertex(s);\n        dfs(G, s);\n    }\n\n    public DirectedDFS(Digraph G, Iterable<Integer> sources) {\n        marked = new boolean[G.V()];\n        validateVertices(sources);\n        for (int v : sources) {\n            if (!marked[v])\n                dfs(G, v);\n        }\n    }\n\n    private void dfs(Digraph G, int v) {\n        count++;\n        marked[v] = true;\n        for (int w : G.adj(v)) {\n            if (!marked[w]) {\n                dfs(G, w);\n            }\n        }\n    }\n\n    public boolean marked(int v) {\n        validateVertex(v);\n        return marked(v);\n    }\n\n    public int count() {\n        return count;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V) {\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1));\n        }\n    }\n\n    private void validateVertices(Iterable<Integer> vertices) {\n        if (vertices == null)\n            throw new IllegalArgumentException(\"argument is null\");\n        int V = marked.length;\n        for (int v : vertices) {\n            if (v < 0 || v >= V)\n                throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1));\n        }\n    }\n}\n```\n\n有向环，即有向图中的环。\n有向图的实际应用中，有一类是调度问题，即给定一组任务并安排它们的执行顺序，限制条件是这些任务的执行方法和起始时间。限制条件还可能包括任务的耗时和资源的消耗等。而这之中最重要的要属于优先级限制，它指明了哪些任务必须在哪些任务之前完成。\n假设任务x在任务y之前完成，任务y在任务z之前完成，任务z在任务x之前完成，那这三个任务是不可能完成的。\n以上的内容在有向图中的体现就是图中存在环。\n那么给定一幅有向图，其中存在有向环吗？存在话，按照路径的方向从某个顶点开始返回自己来找到环上的所有顶点。\nJava的实现：\n\n```java\n//  检测给定的图中是否存在有向环\n\nimport java.util.Stack;\n\npublic class DirectedCycle {\n    private boolean[] marked;// 标记\n    private int[] edgeTo; // 第一次经过某点的边\n    private boolean[] onStack; // 表示顶点在栈中\n    private Stack<Integer> cycle; // 存储路径用的栈\n\n    public DirectedCycle(Digraph G) {\n        marked = new boolean[G.V()];\n        onStack = new boolean[G.V()];\n        edgeTo = new int[G.V()];\n        for (int v = 0; v < G.V(); v++) {\n            if (!marked[v] && cycle == null)\n                dfs(G, v);\n        }\n    }\n\n    private void dfs(Digraph G, int v) {\n        onStack[v] = true; // 存储递归调用期间栈上的顶点\n        marked[v] = true;\n        for (int w : G.adj(v)) {\n            if (cycle != null)\n                return;\n            else if (!marked[w]) {\n                edgeTo[w] = v;\n                dfs(G, w);\n            }\n\n            else if (onStack[w]) { // 如果某个顶点存在于栈中 && 且被标记了 则构成了一个有向环\n                cycle = new Stack<Integer>();\n                for (int x = v; x != w; x = edgeTo[x]) {\n                    cycle.push(x);\n                }\n                cycle.push(w);\n                cycle.push(v);\n                assert check();\n            }\n        }\n        onStack[v] = false;\n    }\n\n    public boolean hasCycle() {\n        return cycle != null;\n    }\n\n    public Iterable<Integer> cycle() {\n        return cycle;\n    }\n\n    private boolean check(){\n        if(hasCycle()){\n            int first =-1,last=-1;\n            for(int v:cycle()){\n                if(first==-1) first=v;\n                last=v;\n            }\n            if(first!=last){\n                System.err.printf(\"cycle begins with %d and ends with %d\\n\", first, last);\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n","tags":["算法"]},{"title":"符号图","url":"%2F2019%2F10%2F15%2F%E7%AC%A6%E5%8F%B7%E5%9B%BE%2F","content":"\n实际应用中，图都是通过文件或者网页定义的，使用的是字符串而非整数来表示和指代顶点。\n因此就出现了符号图这类数据结构。\n符号图中使用了三种数据结构：\n符号表，数组，图。\n其中符号表内存储了String类型的键和int类型的值。\n数组内存储的是符号表中的键值对的反向，即数组的索引是符号表的键值对中的值，数组索引对应的值恰好是符号表内键值对中对应的键。\n从以下图片可以很直观的看到具体的说明。\n![symbol-graph](https://isshl.me/img/symbol-graph.png)\nJava的实现如下：具体的运行过程见注释。\n\n```java\npublic class SymbolGraph {\n    private ST<String, Integer> st;\n    private String[] keys;\n    private Graph graph;\n\n    public SymbolGraph(String filename, String delimiter) {\n        st = new ST<String, Integer>();// 创建符号表\n\n        // 读取文件\n        In in = new In(filename);\n        // 将读取的文本信息 添加到符号表中，key是String Value是st的大小\n        while (!in.isEmpty()) {\n            String[] a = in.readLine().split(delimiter);\n            for (int i = 0; i < a.length; i++) {\n                if (!st.contains(a[i]))\n                    st.put(a[i], st.size());// key(String)-val(int)\n            }\n        }\n        // 将st中的key和val对调 val是int型\n        keys = new String[st.size()];\n        for (String name : st.keys()) {\n            keys[st.get(name)] = name;// keys[i]=name\n        }\n        // 构建图\n        graph = new Graph(st.size());\n        in = new In(filename);\n        while (in.hasNextLine()) {// 构建图\n            String[] a = in.readLine().split(delimiter);\n            int v = st.get(a[0]);\n            for (int i = 1; i < a.length; i++) {\n                int w = st.get(a[i]);\n                graph.addEdge(v, w);\n            }\n        }\n    }\n\n    public int indexOf(String s) {\n        return st.get(s);\n    }\n\n    public String nameOf(int v) {\n        validateVertex(v);\n        return keys[v];\n    }\n\n    public Graph graph() {\n        return graph;\n    }\n\n    private void validateVertex(int v) {\n        int V = graph.V();\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1));\n    }\n\n}\n```\n\n\n","tags":["算法"]},{"title":"深度优先搜索的一些应用","url":"%2F2019%2F10%2F14%2F%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8%2F","content":"\n利用深度优先搜索可以找出一幅图中所有的连通分量。\nJava实现如下：其中的注释解释了代码的运行过程。\n\n```java\npublic class CC {\n    private boolean[] marked;// 标记顶点 也是起点\n    private int[] id;// 将同一连通分量重的顶点和连通分量的标识符关联\n    private int[] size;// 给定的连通分量重的顶点数量\n    private int count; // 连通分量数量\n\n    public CC(Graph G) {\n        marked = new boolean[G.V()];\n        id = new int[G.V()];\n        size = new int[G.V()];\n        for (int v = 0; v < G.V(); v++) {\n            if (!marked[v]) {\n                dfs(G, v);\n                count++;\n            }\n        }\n    }\n\n    private void dfs(Graph G, int v) {\n        marked[v] = true;// 标记顶点\n        id[v] = count;// 将连通分量中的顶点和连通分量的标识符关联\n        size[count]++; // 增加连通分量中的顶点数\n        for (int w : G.adj(v)) { // 递归\n            if (!marked[w]) {\n                dfs(G, w);\n            }\n        }\n    }\n\n    // 返回顶点关联的连通分量\n    public int id(int v) {\n        validateVertex(v);\n        return id[v];\n    }\n\n    // 返回连通分量中的顶点数量\n    public int size(int v) {\n        validateVertex(v);\n        return size[id[v]];\n    }\n\n    //连通分量的数量\n    public int count() {\n        return count;\n    }\n\n    // 判断两个顶点是否在同一个连通分量内\n    public boolean connected(int v, int w) {\n        validateVertex(v);\n        validateVertex(w);\n        return id[v] == id[w];\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not betweent 0 and \" + (V - 1));\n    }\n}\n```\n\n判断图是否是无环图。\n首先假设某图中有一条边v-w，我们用edgeTo[w]=v表示v-w是第一次访问w时经过的边，在以下java实现中，dfs方法添加了一个int形参，其保存的值是v，这样当图中的某些结点可以构成一个环时，可以排除平行边。原因是当检测环时，相对于环的起点，环中的倒数第二个顶点在检查其邻接表内的顶点是否被标记时，假如检测到的顶点和其第一次被标记时的边的另一个顶点相同，则不能确定是否存在环。如果排除掉这种可能，且其邻接表内的顶点均被标记过，则存在环。\n\n```java\nimport java.util.Stack;\n\npublic class Cycle {\n    private boolean[] marked;\n    private int[] edgeTo;\n    private Stack<Integer> cycle;\n\n    public Cycle(Graph G) {\n        if (hasSelfLoop(G))\n            return;\n        if (hasParallelEdges(G))\n            return;\n        marked = new boolean[G.V()];\n        edgeTo = new int[G.V()];\n        for (int v = 0; v < G.V(); v++) {\n            if (!marked[v])\n                dfs(G, -1, v);\n        }\n    }\n\n    private boolean hasSelfLoop(Graph G) {\n        for (int v = 0; v < G.V(); v++) {\n            for (int w : G.adj(v)) {\n                if (v == w) { // 检测自旋 就是检测是否存有一条边的起点和终点是同一个顶点\n                    cycle = new Stack<Integer>();\n                    cycle.push(v);\n                    cycle.push(w);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean hasParallelEdges(Graph G) {\n        marked = new boolean[G.V()];\n\n        for (int v = 0; v < G.V(); v++) {\n            for (int w : G.adj(v)) {\n                if (marked[w]) {\n                    cycle = new Stack<Integer>();\n                    cycle.push(v);\n                    cycle.push(w);\n                    cycle.push(v);\n                    return true;\n                }\n                marked[w] = true;\n            }\n            for (int w : G.adj(v)) {\n                marked[w] = false;\n            }\n        }\n        return false;\n    }\n\n    public boolean hasCycle() {\n        return cycle != null;\n    }\n\n    public Iterable<Integer> cycle(){\n        return cycle;\n    }\n\n    private void dfs(Graph G, int u, int v) {\n        marked[v] = true;\n        for (int w : G.adj(v)) {\n            if (cycle != null) // 存在环 \n                return;\n            if (!marked[w]) { // 邻接表内的顶点未被标记 \n                edgeTo[w] = v;// 第一次访问时候的边\n                dfs(G, v, w);\n            } \n            else if (w != u) { // 邻接表内的某个顶点既被标记过又不等于edgeTo[w]时，存在环\n                cycle = new Stack<Integer>();\n                for (int x = v; x != w; x = edgeTo[x]) {\n                    cycle.push(x);\n                }\n                cycle.push(w);\n                cycle.push(v);\n            }\n        }\n    }\n}\n```\n\n二分图 待更新~","tags":["算法"]},{"title":"图的基础&深度优先搜索&广度优先搜索","url":"%2F2019%2F10%2F14%2F%E5%9B%BE%E7%9A%84%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%2F","content":"\n图是一种抽象的数学对象。\n图的种类有很多，这里只涉及到以下几种：无向图、有向图、加权图、加权有向图。\n图的实际应用包括：地图、网页信息、电路、任务调度、商业交易、配对、计算机网络、软件、社交网络等。\n关于图的研究历史悠久，这里我们只关注图的一些基本性质。\n也许包括：\n顶点与顶点之间是否存在连接？\n有多少个顶点与指定顶点相连？\n两个顶点之间最短的连通路径是什么？等等。\n这几个问题涉及到关于图的基础算法：深度优先搜索和广度优先搜索。\n\n在介绍图的基础算法之前，先来介绍一下关于图的一些术语。\n图：由一组顶点和一组能连接两个顶点的边组成的结构。\n自环：由一条连接顶点和其自身的边。\n平行边：两条连接同一对顶点的边。\n两个顶点通过一条边相连是，即相邻的。\n这条边则依附于这两个顶点。\n某个顶点依附于它的边数成为度数。\n子图是一幅图的所有边的一个子集组成的图。\n路径是由边顺序连接的一些列顶点。\n简单路径是没有重复顶点的路径。\n环是一条至少含有一条边且起点和终点相同的路径。\n简单环是一条不含有重复顶点和边的环。\n路径或者环的长度为其中所包含的边数。\n连通图：任意一个顶点都可以通过一条路径到达任意另一个顶点的图。\n无环图：不存在环的图。\n树是一个无环连通图。互不相连的树组成森林。\n密度：图中存在的顶点对占可能连接的顶点对的比例。\n以上就是关于图的一些术语。\n\n在介绍图的基础算法之前，再介绍一下无向图的概念。\n无向图是由顶点和连接顶点的边组成的。\n它的数据结构是一个数组。\n数组的索引为无向图的顶点。\n数组内的每一项都是一个邻接表，即保存了与索引顶点相邻的所有顶点的一个链表结构。\n实现这个链表结构的抽象数据类型是Bag。\n以下是Graph的Java实现：\n\n```java\nimport java.util.NoSuchElementException;\nimport java.util.Stack;\n\npublic class Graph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n\n    private final int V;// 顶点数\n    private int E;// 边数\n    private Bag<Integer>[] adj;\n\n    // 构造函数\n    public Graph(int V) {\n        if (V < 0)\n            throw new IllegalArgumentException(\"Number of vertices must be nonnegative\");\n        this.V = V;\n        this.E = 0;\n        adj = (Bag<Integer>[]) new Bag[V];\n        for (int v = 0; v < V; v++) {\n            adj[v] = new Bag<Integer>();\n        }\n    }\n\n    public Graph(In in) {\n        try {\n            this.V = in.readInt();\n            if (V < 0)\n                throw new IllegalArgumentException(\"Number of vertices must be nonnegative\");\n            adj = (Bag<Integer>[]) new Bag[V];\n            for (int v = 0; v < V; v++) {\n                adj[v] = new Bag<Integer>();\n            }\n            int E = in.readInt();\n            if (E < 0)\n                throw new IllegalArgumentException(\"Number of vertices must be nonnegative\");\n            for (int i = 0; i < E; i++) {\n                int v = in.readInt();\n                int w = in.readInt();\n                validateVertex(v);\n                validateVertex(w);\n                addEdge(v, w);\n            }\n        } catch (NoSuchElementException e) {\n            throw new IllegalArgumentException(\"invalid input format in Graph constructor\", e);\n        }\n    }\n\n    public Graph(Graph G) {\n        this(G.V());\n        this.E = G.E();\n        for (int v = 0; v < G.V(); v++) {\n            Stack<Integer> stack = new Stack<Integer>();\n            for (int w : G.adj[v]) {\n                stack.push(w);\n            }\n            for (int w : stack) {\n                adj[v].add(w);\n            }\n        }\n    }\n\n    public int V() {\n        return V;\n    }\n\n    public int E() {\n        return E;\n    }\n\n    public void validateVertex(int v) {\n        if (v < 0 || v > V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1));\n    }\n\n    public void addEdge(int v, int w) {\n        validateVertex(v);\n        validateVertex(w);\n        E++;\n        adj[v].add(w);\n        adj[w].add(v);\n    }\n\n    public Iterable<Integer> adj(int v) {\n        validateVertex(v);\n        return adj[v];\n    }\n\n    public int degree(int v) {\n        validateVertex(v);\n        return adj[v].size();\n    }\n\n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        s.append(V + \" vertices \" + E + \" edges \" + NEWLINE);\n        for (int v = 0; v < V; v++) {\n            s.append(v + \": \");\n            for (int w : adj[v]) {\n                s.append(w + \" \");\n            }\n            s.append(NEWLINE);\n        }\n        return s.toString();\n    }\n}\n```\n\n在上面的内容中有说到两个顶点是否相连通问题，这个问题通常用深度优先算法来解决。\n深度优先算法，是从一个顶点出发，将路径中第一次经过的顶点和边打上标记，直至遇到已被标记过的顶点，此时返回上一层的顶点，继续标记该顶点的剩余相邻顶点，直至该顶点所有的相邻顶点都标记完毕，则返回到更上一层的顶点，继续以上操作，直至图中所有顶点都被标记完毕。\n所以深度优先算法中，一开始被标记的顶点都处于图中很深的位置。\n以下是其Java实现：\n\n```java\nimport java.util.Stack;\n\npublic class DepthFirstPaths {\n    private boolean[] marked;// 标记路径上的点\n    private int[] edgeTo;// 路径上连接最后的顶点的边\n    private final int s;// 起点\n\n    public DepthFirstPaths(Graph G, int s) {\n        this.s = s;\n        edgeTo = new int[G.V()];\n        marked = new boolean[G.V()];\n        validateVertex(s);\n        dfs(G, s);\n    }\n\n    public void dfs(Graph G, int v) {\n        marked[v] = true;\n        for (int w : G.adj(v)) {\n            if (!marked[w]){\n                edgeTo[w] = v;\n                dfs(G, w);\n            }\n        }\n    }\n\n    public boolean hasPathTo(int v){\n        validateVertex(v);\n        return marked[v];\n    }\n\n\n    public Iterable<Integer> pathTo(int v) {\n        validateVertex(v);\n        if (!hasPathTo(v))\n            return null;\n        Stack<Integer> path = new Stack<Integer>();\n        // edgeTo[]的值是指向该点的点 只要存在值则表示有边连接该顶点 \n        for (int x = v; x != s; x = edgeTo[x]) {\n            path.push(x);\n        }// s-v的路径中除去s以外的点\n        path.push(s);\n        return path;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1));\n    }\n}\n```\n\n关于图的另一个问题是，既然顶点和顶点是相连的，那他们之间存在的路径中，哪一条是最短路径？对于这个问题，深度优先搜索是无能为力。此时就需要广度优先搜索了。\n广度优先搜索，是从一个顶点出发，将该顶点邻接表内的所有顶点都标记出来，然后在依次将该邻接表内的顶点的邻接表内的顶点也标记出来，如此一直进行下去。这种遍历方式，很适合用队列的数据结构来表示。\n假设现在需要找到从s到v的最短的路径。\n按照广度优先搜索算法来表示：从s开始，先在距离s为一条边的顶点中寻找v，若没找到，则继续在距离s为两条边的顶点中寻找，以此类推。\n下面是其java实现。\n\n```java\nimport java.util.Stack;\n\npublic class BreadthFirstPaths {\n    private static final int INFINITY = Integer.MAX_VALUE;\n\n    private boolean[] marked;// 被标记的顶点\n    private int[] edgeTo; // 返回值是指向一个顶点的另一个顶点\n    private int[] distTo;// 距离\n\n    public BreadthFirstPaths(Graph G, int s) {\n        marked = new boolean[G.V()];\n        distTo = new int[G.V()];\n        edgeTo = new int[G.V()];\n        validateVertex(s);\n        bfs(G, s);\n    }\n\n    // 广度优先搜索\n    private void bfs(Graph G, int s) {\n        Queue<Integer> q = new Queue<Integer>();\n        for (int v = 0; v < G.V(); v++) {\n            distTo[v] = INFINITY;\n        }\n        distTo[s] = 0;\n        marked[s] = true;\n        q.enqueue(s);\n\n        while (!q.isEmpty()) {\n            int v = q.dequeue();\n            for (int w : G.adj(v)) {\n                if (!marked[w]) {\n                    edgeTo[w] = v;\n                    distTo[w] = distTo[v] + 1;\n                    marked[w] = true;\n                    q.enqueue(w);\n                }\n            }\n        }\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v <= V) {\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1));\n        }\n    }\n\n    public BreadthFirstPaths(Graph G, Iterable<Integer> sources) {\n        marked = new boolean[G.V()];\n        distTo = new int[G.V()];\n        edgeTo = new int[G.V()];\n        for (int v = 0; v < G.V(); v++) {\n            distTo[v] = INFINITY;\n        }\n        validateVertices(sources);\n        bfs(G, sources);\n    }\n\n    private void bfs(Graph G, Iterable<Integer> sources) {\n        Queue<Integer> q = new Queue<Integer>();\n        for (int s : sources) {\n            marked[s] = true;\n            distTo[s] = 0;\n            q.enqueue(s);\n        }\n        while (!q.isEmpty()) {\n            int v = q.dequeue();\n            for (int w : G.adj(v)) {\n                if (!marked[w]) {\n                    edgeTo[w] = v;\n                    distTo[w] = distTo[v] + 1;\n                    marked[w] = true;\n                    q.enqueue(w);\n                }\n            }\n        }\n    }\n\n    private void validateVertices(Iterable<Integer> vertices) {\n        if (vertices == null)\n            throw new IllegalArgumentException(\"argument is null\");\n        int V = marked.length;\n        for (int v : vertices) {\n            if (v < 0 || v >= V) {\n                throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1));\n            }\n        }\n    }\n\n    public boolean hasPathTo(int v) {\n        validateVertex(v);\n        return marked[v];\n    }\n\n    public int distTo(int v) {\n        validateVertex(v);\n        return distTo(v);\n    }\n\n    // 最短距离路径\n    public Iterable<Integer> pathTo(int v) {\n        validateVertex(v);\n        if (!hasPathTo(v))\n            return null;\n        Stack<Integer> path = new Stack<Integer>();\n        int x;\n        for (x = v; distTo[x] != 0; x = edgeTo[x]) {\n            path.push(x);\n        }\n        path.push(x);\n        return path;\n    }\n}\n```\n","tags":["算法"]},{"title":"暂停一下","url":"%2F2019%2F10%2F13%2F%E6%9A%82%E5%81%9C%E4%B8%80%E4%B8%8B%2F","content":"\n哪怕一开始大多数单纯的想法，会随着时间一点一点的消逝，如果，\n等你发现原来我还在原地，又或者在原本你想要去的地方。你会来吗？\n时间最神奇的地方是会给你带来想要的，而不仅仅只有不好的。\n我已记不清，这一年多时间是怎么过来的。几乎每天都一样。\n我想既然没有特别的事情，那就不需要记下太多东西。\n早睡早起，规律锻炼，读一些书。多完美的生活！\n甚至都不需要自己变得更好。\n甚至有一段时间，一个人走到城市的另一半，吹吹风。\n以前认识个人很喜欢在人多的地方找个角落坐下，就这么看着周围的人来人往。\n我以为这是很孤单的事。但也许很少吐露内心的人，大抵会如此。\n\n安静着是没准备好伸手去拥抱谁。\n会变得假装外向，是因为有好事发生。\n而听故事，就只当故事听，从不计较真假，有趣就好。\n夜里出去散步吹吹风。\n这风除却了嘈杂后，还有隐约可以闻到的桂花香。\n每年九十月，这片地上从没叫人失望过。\n也包括在路上不小心踩到的不洁之物。\n想着弄干净，一秒也没想过运气会不会变好。\n趁着路边还有湿漉漉的枯叶夹在泛黄的草地上就走了过去。\n\n操场边上搭了高台，引去了一大堆看热闹的。\n来回走的路，黄灯穿透还算密实的叶子投下星星点点，梧桐好像。\n两三处热闹的商场和小区，多了点活泼的气息。\n提着的三三两两袋子，装满了不知所以的东西。\n说笑的人漫走着。\n擦肩而过时，偶尔偷听两句闲言碎语。\n居然有听到房子的事情，我天这周边的拆迁暴发户还不够多嘛。\n中产的生活方式。我以为并不是真正的生活，当比较成了目的时。\n\n以后养条狗吧，我不开心了它逗我。它不开心了我不理它，自己的事情自己做。\n老早前养过不下5只猫，这帮主子那时我们吃什么它吃什么哪像现在。\n偶尔它们自己会给自己加个餐，抓个鸟偷个鱼什么的很正常。\n自从搬了家，一切都变了。\n就养条边牧吧。\n\n西北角是一片在建高楼，跑步路过时，偶尔听见几句外地方言。\n应该说这片地方，气息早变了，热闹欢快了，甚至变得有趣了。\n我不太适应人多的地方。渺小的似乎不存在，但是又被其中的一些吸引。\n因为很多生活气息，很多现实，很多既不美也不丑的事情。\n\n我想做个路人甲。\n需要时变主角，虽力不能扛鼎，但靠得住。\n不需要时，存在感为0，自在惬意甚至有点想偷笑。\n你想见我时，我都在。不想见时，假装隐身看着你，随时准备着。\n人年轻时不都是这样嘛，怎么长大就害怕了。\n不用纠结未来，至少此时此刻我们都真实的存在着，以及真正的掌控着这杂乱的生活。\n一定不要害怕。\n(完)","tags":["日常"]},{"title":"基于线性探测法的散列表","url":"%2F2019%2F10%2F12%2F%E5%9F%BA%E4%BA%8E%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%2F","content":"\n基于拉链法的散列表中，结点存储在链表中，而基于线性探测法的散列表，则将结点排列在一个有空元素的数组中。避免碰撞的处理方式是增加数组中的空位。\n基于线性探测法的散列表使用两个数组，一个用来存储键，一个用来存储值。通过散列函数计算出键对应的数组的索引，从而来访问数据。通常键和值的数组相同的索引对应的是一对相关联的键值对。\n其java实现如下：\n更多的关于算法的理解，则写在注释内。\n\n```java\npublic class LinearProbingHashST<Key, Value> {\n    private static final int INIT_CAPACITY = 4;\n\n    private int n;// 键值对数量\n    private int m;// 数组长度\n    private Key[] keys;\n    private Value[] vals;\n\n    public LinearProbingHashST() {\n        this(INIT_CAPACITY);\n    }\n\n    public LinearProbingHashST(int capacity) {\n        m = capacity;\n        n = 0;\n        keys = (Key[]) new Object[m];\n        vals = (Value[]) new Object[m];\n    }\n\n    public int size() {\n        return n;\n    }\n\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    // 是否包含给定的键\n    public boolean contains(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to contains() is null\");\n        return get(key) != null;\n    }\n\n    // 散列函数\n    private int hash(Key key) {\n        return (key.hashCode() & 0x7fffffff) % m;\n    }\n\n    // 调整数组的大小\n    private void resize(int capacity) {\n        LinearProbingHashST<Key, Value> temp = new LinearProbingHashST<Key, Value>(capacity);\n        for (int i = 0; i < m; i++) {\n            if (keys[i] != null) {\n                temp.put(keys[i], vals[i]);\n            }\n        }\n    }\n\n    // 插入键值对\n    public void put(Key key, Value val) {\n        // 边界情况\n        if (key == null)\n            throw new IllegalArgumentException();\n        if (val == null) {\n            delete(key);\n            return;\n        }\n        // 增加容量 以保证查找的探测次数保持在一个很小的常数范围内\n        if (n >= m / 2)\n            resize(2 * m);\n        // 查找key是否存在于数组内\n        int i;\n        for (i = hash(key); keys[i] != null; i = (i + 1) % m) {\n            if (keys[i].equals(key)) // 存在则直接修改其值\n                vals[i] = val;\n            return;\n        }\n        // 若没有找到，即遇到一个空值，则在该位置添加一个键值对\n        keys[i] = key;\n        vals[i] = val;\n        n++;\n    }\n\n    // 查找给定键的值\n    public Value get(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to get() is null\");\n        // 找到则返回其值\n        for (int i = hash(key); keys[i] != null; i = (i + 1) % m) {\n            if (keys[i].equals(key))\n                return vals[i];\n        }\n        return null;\n    }\n    \n    // 删除任意值 \n    public void delete(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to delete() is null\");\n        if (!contains(key))\n            return;\n        // 找到key的位置\n        int i = hash(key);\n        while (!key.equals(keys[i])) {\n            i = (i + 1) % m;\n        }\n        // 删除key-val\n        keys[i] = null;\n        vals[i] = null;\n        // 重新计算同一键簇的散列值 因为删除位置为空，会造成后面的结点无法被搜到\n        i = (i + 1) % m;\n        while (keys[i] != null) {\n            // 删除\n            Key keyToRehash = keys[i];\n            Value valToRehash = vals[i];\n            keys[i] = null;\n            vals[i] = null;\n            n--;\n            // 重新插入\n            put(keyToRehash, valToRehash);\n            i = (i + 1) % m;\n        }\n        n--;\n        if (n > 0 && n <= m / 8)\n            resize(m / 2);\n    }\n\n    public Iterable<Key> keys() {\n        Queue<Key> queue = new Queue<Key>();\n        for (int i = 0; i < m; i++) {\n            if (keys[i] != null)\n                queue.enqueue(keys[i]);\n        }\n        return queue;\n    }\n}\n```\n\n\n","tags":["算法"]},{"title":"基于拉链法的散列表","url":"%2F2019%2F10%2F12%2F%E5%9F%BA%E4%BA%8E%E6%8B%89%E9%93%BE%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%2F","content":"\n如果符号表的键都是小整数，则可以用数组来存储无序的符号表，即键为数组的索引，而数组在键 i 处存储的值即为它对应的值。那么怎样使符号表中的键转化为数组中的索引呢。\n首先，使用散列的查找算法，通常分两步，第一步是将被查找的键转化为数组的一个索引，第二步是处理碰撞冲突的过程。\n键的类型不会只有整数，还有可能是别的类型，甚至是自定义类型，所以将各种类型的键转换为一个小整数，需要一个函数，这个函数被称为散列函数。严格来说，对于每种类型的键都需要一个与之对应的散列函数。\n一个优秀的散列函数需满足以下几点要求：\n  -一致性：等价的键必然产生相等的散列值\n  -高效性：计算简便\n  -均匀性：均匀地散列所有键\n既然需要为每种数据类型提供对应的散列函数，因此在java中，所有的数据类型都继承了一个能够返回32比特整数的方法--hashCode()，与此同时，hashCode()方法与equals()方法的表现必须一致，即若两个键是相等的，则两个键的hashCode方法的返回值也相同，hashCode方法返回值不同，则两个键不相等。而hashCode方法返回值相同，两个键也可能不同，此时需要通过equals方法来判断。\n散列表的实现方式有两种：拉链法和线性探测法。\n这里先说拉链法。\n拉链法的一种实现方法是基于原始的链表数据结构，即扩展的基于无序链表的SequentialSearchST类。\n即：数组中的每一个对象都是SequentialSearchST对象。符号表的键通过散列函数得出对应的索引，然后通过索引找到链表将键值对存储在其中，不相同的键相同散列值的情况，则通过依次将键值对存储在索引对应的SequentialSearchST的链表中，从而避免的碰撞。\nJava的实现如下：\n\n```java\npublic class SeparateChainingHashST<Key, Value> {\n    private static final int INIT_CAPACITY = 4;\n\n    private int n;\n    private int m;\n    private SequentialSearchST<Key, Value>[] st;\n\n    public SeparateChainingHashST() {\n        this(INIT_CAPACITY);\n    }\n\n    public SeparateChainingHashST(int m) {\n        this.m = m;\n        st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[m]; // 数组\n        for (int i = 0; i < m; i++) {\n            st[i] = new SequentialSearchST<Key, Value>(); // 数组中的每一项都是一条链表\n        }\n    }\n\n    private void resize(int chains) {\n        SeparateChainingHashST<Key, Value> temp = new SeparateChainingHashST<Key, Value>(chains);\n        for (int i = 0; i < m; i++) {\n            for (Key key : st[i].keys()) {\n                temp.put(key, st[i].get(key));\n            }\n        }\n        this.m = temp.m;\n        this.n = temp.n;\n        this.st = temp.st;\n    }\n\n    // 散列函数 or hash函数\n    private int hash(Key key) {\n        return (key.hashCode() & 0x7fffffff) % m;\n    }\n\n    public int size() {\n        return n;\n    }\n\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    public boolean contains(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to contains() is null\");\n        return get(key) != null;\n    }\n\n    public Value get(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to get() is null\");\n        int i = hash(key);\n        return st[i].get(key);\n    }\n\n    public void put(Key key, Value val) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to put() is null\");\n        if (val == null) {\n            delete(key);\n            return;\n        }\n\n        if (n >= 10 * m)\n            resize(2 * m);\n        int i = hash(key);\n        if (!st[i].contains(key))\n            n++;\n        st[i].put(key, val);\n    }\n\n    public void delete(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to delete() is null\");\n        int i = hash(key);\n        if (st[i].contains(key))\n            n--;\n        st[i].delete(key);\n        if (m > INIT_CAPACITY && n <= 2 * m)\n            resize(m / 2);\n    }\n\n    public Iterable<Key> keys() {\n        Queue<Key> queue = new Queue<Key>();\n        for (int i = 0; i < m; i++) {\n            for (Key key : st[i].keys())\n                queue.enqueue(key);\n        }\n        return queue;\n    }\n}\n```\n\n","tags":["算法"]},{"title":"平衡查找树","url":"%2F2019%2F10%2F07%2F%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91%2F","content":"\n什么是平衡查找树？\n平衡查找树是一颗空树，或者非空时任意结点的左右子树也是平衡二叉树，并且高度差的绝对值不大于1。平衡查找树的种类很多。Algorithm书中提到的有2-3树和红黑树。\n\n2-3树是一颗空树，或者不是空树时，树中存在两种结点即：2-结点和3-结点。\n2-结点包含单个键和左右两条链接，左链接指向的左子树中的键均小于该结点，右链接指向的右子树中的键都大于该结点。\n3-结点包含2个键和三条链接，左链接指向的左子树中的键均小于该结点，中链接指向的子树中的键大小介于该结点的两个键之间，右链接指向的右子树中的键均大于该结点。\n而2-3树的叶子结点的链接指向空树，均为空链接。\n完美平衡的2-3树，则指的是所有空链接到根结点的距离相等。\n2-3树的查找和二叉树的查找类似。\n插入新的结点，则需要分以下几种情况。\n新结点在插入之前，需要进行一次未命中的查找，以确定新结点插入的位置。\n若插入的位置在2-结点上，则直接将新结点与该结点组合长一个3-结点。\n若插入的位置在3-结点上，且这颗树只有这一个结点，则将3-结点临时变成4-结点，然后将这个4-结点的中间元素提出，将剩余结点变成2个2-结点，树高加1，以保持树的平衡。\n若插入的位置在3-结点上，且这个结点的父结点是2-结点，则将3-结点临时变为4-结点，然后将4-结点的中间元素插入到父结点2-结点中，并将父结点变成3-结点，4-结点的剩余元素变成2个2-结点。\n若插入的位置在3-结点上，且这个结点的父结点是3-结点，则将3-结点临时变为4-结点，然后将4-几点的中间元素插入到父结点3-结点中，这时父结点3-结点也变成了4-结点，则继续将父结点中的中间元素插入到其父结点中，以此向上不断插入，直至遇到一个2-结点，将2-结点变成3-结点，或者遇到根结点是3-结点，则将根结点临时变成4-结点，然后将该结点的中间元素提出变成根结点，剩余结点变成2个2-结点，树高加1。\n\n红黑树是一颗2-3树，也是一颗二叉查找树。\n在红黑树中，3-结点内的两个键，以一条红色链接连接起来，且链接为左链接。而普通链接则为黑色链接。\n没有任何一个结点同时和两条红色链接相连。\n完美黑色平衡的红黑树，任意空链接到根节点的路径上黑色链接数量相同。\n红黑树的实现，put和delete方法略复杂。以下是java实现：\n\n```java\nimport java.util.NoSuchElementException;\n\npublic class RedBlackBST<Key extends Comparable<Key>, Value> {\n    private static final boolean RED = true;\n    private static final boolean BLACK = false;\n\n    private Node root;\n\n    private class Node {\n        private Key key;\n        private Value val;\n        private Node left, right;\n        private boolean color;\n        private int size;\n\n        public Node(Key key, Value val, boolean color, int size) {\n            this.key = key;\n            this.val = val;\n            this.color = color;\n            this.size = size;\n        }\n    }\n\n    public RedBlackBST() {\n    }\n\n    // 结点辅助方法\n\n    private boolean isRed(Node x) {\n        if (x == null)\n            return false;\n        return x.color == RED;\n    }\n\n    private int size(Node x) {\n        if (x == null)\n            return 0;\n        return x.size;\n    }\n\n    public int size() {\n        return size(root);\n    }\n\n    public boolean isEmpty() {\n        return root == null;\n    }\n\n    // 标准的BST的搜索方法\n\n    // 返回给定键的值\n    public Value get(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to get() is null\");\n        return get(root, key);\n    }\n\n    private Value get(Node x, Key key) {\n        while (x != null) {\n            int cmp = key.compareTo(x.key);\n            if (cmp < 0)\n                x = x.left;\n            if (cmp > 0)\n                x = x.right;\n            else\n                return x.val;\n        }\n        return null;\n    }\n\n    public boolean contains(Key key) {\n        return get(key) != null;\n    }\n\n    public void put(Key key, Value val) {\n        if (key == null)\n            throw new IllegalArgumentException(\"first argument to put() is null\");\n        if (val == null) {\n\n            return;\n        }\n        root = put(root, key, val);\n        root.color = BLACK;\n    }\n    \n    // 二分查找，命中则修改key的val，否则新建一个新的key-val\n    private Node put(Node h, Key key, Value val) {\n        if (h == null)\n            return new Node(key, val, RED, 1);\n\n        int cmp = key.compareTo(h.key);\n        if (cmp < 0)\n            h.left = put(h.left, key, val);\n        if (cmp > 0)\n            h.right = put(h.right, key, val);\n        else\n            h.val = val;\n            \n        // key-val修改或添加后，需要进行红黑边的旋转和修复\n        if (isRed(h.right) && !isRed(h.left))\n            h = rotateLeft(h);\n        if (isRed(h.left) && isRed(h.left.left))\n            h = rotateRight(h);\n        if (isRed(h.left) && isRed(h.right))\n            flipColors(h);\n        h.size = size(h.left) + size(h.right) + 1;\n        return h;\n    }\n\n    // 红黑树删除结点的方法\n\n    // 删除最小的键\n    public void deleteMin() {\n        if (isEmpty())\n            throw new NoSuchElementException(\"BST underflow\");\n        // 假设红黑树是由 根结点和左右子结点组成，则删除最小键的时候需要将这三点合为4-结点\n        if (!isRed(root.left) && !isRed(root.right))\n            root.color = RED;\n        root = deleteMin(root);\n        if (!isEmpty())\n            root.color = BLACK;\n    }\n\n    private Node deleteMin(Node h) {\n        if (h.left == null) {\n            return null;\n        }\n        // 若h结点的左子树和左子树的左子树均为黑色链接 则删除结点时必须将2-结点变成3-结点\n        if (!isRed(h.left) && !isRed(h.left.left)) {\n            h = moveRedLeft(h);\n        }\n\n        h.left = deleteMin(h.left);\n        return balance(h);// 配平\n    }\n\n    // 删除最大的键\n\n    public void deleteMax() {\n        if (isEmpty())\n            throw new NoSuchElementException(\"BST underflow\");\n        // 假设红黑树是由 根结点和左右子结点组成，则删除最小键的时候需要将这三点合为4-结点\n        if (!isRed(root.left) && !isRed(root.right))\n            root.color = RED;\n        root = deleteMax(root);\n        if (!isEmpty())\n            root.color = BLACK;\n    }\n\n    private Node deleteMax(Node h) {\n        // 若左结点为红链接，则转移到右链接上，以便删除时候右链接不是2-结点\n        if (isRed(h.left))\n            h = rotateRight(h);\n        if (h.right == null)\n            return null;\n        // 若h结点的右链接和右链接的左链接是黑色链接，在删除右链接时，需将右链接变成3-结点\n        if (!isRed(h.right) && !isRed(h.right.left))\n            h = moveRedRight(h);\n        h.right = deleteMax(h.right);\n        return balance(h);\n    }\n\n    // 删除任意结点\n\n    public void delete(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to delete() is null\");\n        if (!contains(key))\n            return;\n\n        if (!isRed(root.left) && !isRed(root.right))\n            root.color = RED;\n        root = delete(root, key);\n        if (!isEmpty())\n            root.color = BLACK;\n    }\n\n    private Node delete(Node h, Key key) {\n        if (key.compareTo(h.key) < 0) { // 小于\n            // 保证查找过程中任意当前结点都不是2-结点\n            if (!isRed(h.left) && !isRed(h.left.left)) \n                h = moveRedLeft(h);\n            h.left = delete(h.left, key);\n        } else { \n            // 若左结点为红链接，则右转，以便保证当前结点不是2-结点\n            if (isRed(h.left)) \n                h = rotateRight(h);\n            // 找到要删除的结点，其父结点右链接为空，则转移该结点到右链接上\n            if (key.compareTo(h.key) == 0 && (h.right == null))\n                h = moveRedRight(h);\n            // 找到要删除的结点\n            if (key.compareTo(h.key) == 0) {\n                Node x = min(h.right);// 后继结点\n                h.key = x.key;\n                h.val = x.val;\n                h.right = deleteMin(h.right);\n            } else\n                h.right = delete(h.right, key);\n        }\n        return balance(h);\n    }\n    // 红黑树辅助方法\n\n    // 链接的旋转，并不涉及到颜色,主要提供给插入方法使用\n    // 左链接右转\n    private Node rotateRight(Node h) {\n        Node x = h.left;\n        h.left = x.right;\n        x.right = h;\n        x.color = x.right.color;\n        x.right.color = RED;\n        x.size = h.size;\n        h.size = size(h.left) + size(h.right) + 1;\n        return x;\n    }\n\n    // 右链接左转\n    private Node rotateLeft(Node h) {\n        Node x = h.right;\n        h.right = x.left;\n        x.left = h;\n        x.color = x.left.color;\n        x.left.color = RED;\n        x.size = h.size;\n        h.size = size(h.left) + size(h.right) + 1;\n        return x;\n    }\n\n    // 颜色切换\n    private void flipColors(Node h) {\n        h.color = !h.color;\n        h.left.color = !h.left.color;\n        h.right.color = !h.right.color;\n    }\n\n    // h为红色，它的左结点和左结点的左结点都是普通链接 使h的左结点或者左结点的任意一个结点为红链接\n    // 为了在删除最小结点的时候，使被删除的结点为非2-结点\n    private Node moveRedLeft(Node h) {\n        flipColors(h);\n        if (isRed(h.right.left)) {\n            h.right = rotateRight(h.right);\n            h = rotateLeft(h);\n            flipColors(h);\n        }\n        return h;\n    }\n\n    // h为红色，它的右结点和右结点的左结点为普通链接，使h的右节点或者右节点的任意一个结点为红链接\n    // 为了在删除最大结点的时候，使被删除的结点为非2-结点\n    private Node moveRedRight(Node h) {\n        flipColors(h);\n        if (isRed(h.left.left)) {\n            h = rotateLeft(h);\n            flipColors(h);\n        }\n        return h;\n    }\n\n    // 恢复红黑树的平衡\n    private Node balance(Node h) {\n        if (isRed(h.right))\n            h = rotateLeft(h);\n        if (isRed(h.left) && isRed(h.left.left))\n            h = rotateRight(h);\n        if (isRed(h.left) && isRed(h.right))\n            flipColors(h);\n        h.size = size(h.left) + size(h.right) + 1;\n        return h;\n    }\n\n    // 工具类函数\n\n    // 返回树高\n    public int height() {\n        return height(root);\n    }\n\n    private int height(Node x) {\n        if (x == null)\n            return -1;\n        return 1 + Math.max(height(x.left), height(x.right));\n    }\n\n    // 有序符号表方法\n\n    // 返回最小键\n    public Key min() {\n        if (isEmpty())\n            throw new NoSuchElementException(\"calls min() with empty symbol table\");\n        return min(root).key;\n    }\n\n    private Node min(Node x) {\n        if (x.left == null)\n            return x;\n        else\n            return min(x.left);\n    }\n\n    // 返回最大键\n\n    public Key max() {\n        if (isEmpty())\n            throw new NoSuchElementException(\"calls max() with empty symbol table\");\n        return max(root).key;\n    }\n\n    private Node max(Node x) {\n        if (x == null)\n            return x;\n        else\n            return max(x.right);\n    }\n\n    // 返回<=给定键的最大键\n    public Key floor(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to floor() is null\");\n        if (isEmpty())\n            throw new IllegalArgumentException(\"calls floor() with empty symbol table\");\n        return floor(root, key).key;\n    }\n\n    private Node floor(Node x, Key key) {\n        if (x == null)\n            return null;\n        int cmp = key.compareTo(x.key);\n        if (cmp < 0)\n            return floor(x.left, key);\n        if (cmp == 0)\n            return x;\n        Node t = floor(x.right, key);\n        if (t != null)\n            return t;\n        else\n            return x;\n    }\n\n    // 返回>=给定键的最小键\n    public Key ceiling(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to ceiling() is null\");\n        if (isEmpty())\n            throw new IllegalArgumentException(\"calls ceiling() with empty symbol table\");\n        return ceiling(root, key).key;\n    }\n\n    private Node ceiling(Node x, Key key) {\n        if (x == null)\n            return null;\n        int cmp = key.compareTo(x.key);\n        if (cmp == 0)\n            return x;\n        if (cmp > 0)\n            return ceiling(x.right, key);\n        Node t = floor(x.left, key);\n        if (t != null)\n            return t;\n        else\n            return x;\n    }\n\n    // 返回符号表中排序k的键\n    public Key select(int k) {\n        if (k < 0 || k >= size())\n            throw new IllegalArgumentException(\"argument to select() is incvalid: \" + k);\n        Node x = select(root, k);\n        return x.key;\n    }\n\n    private Node select(Node x, int k) {\n        int t = size(x.left);\n        if (t > k)\n            return select(x.left, k);\n        else if (t < k)\n            return select(x.right, k - t - 1);\n        else\n            return x;\n    }\n\n    // 返回指定key在符号表中的排序\n    public int rank(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to rank() is null\");\n        return rank(key, root);\n    }\n\n    private int rank(Key key, Node x) {\n        if (x == null)\n            return 0;\n        int cmp = key.compareTo(x.key);\n        if (cmp < 0)\n            return rank(key, x.left);\n        if (cmp > 0)\n            return 1 + size(x.left) + rank(key, x.right);\n        else\n            return size(x.left);\n    }\n\n    // 范围内计算和范围内搜索\n\n    public Iterable<Key> keys() {\n        if (isEmpty())\n            return new Queue<Key>();\n        return keys(min(), max());\n    }\n\n    public Iterable<Key> keys(Key lo, Key hi) {\n        if (lo == null)\n            throw new IllegalArgumentException(\"first argument to keys() is null\");\n        if (hi == null)\n            throw new IllegalArgumentException(\"second argument to keys() is null\");\n\n        Queue<Key> queue = new Queue<Key>();\n        keys(root, queue, lo, hi);\n        return queue;\n    }\n\n    private void keys(Node x, Queue<Key> queue, Key lo, Key hi) {\n        if (x == null)\n            return;\n        int cmplo = lo.compareTo(x.key);\n        int cmphi = hi.compareTo(x.key);\n        if (cmplo < 0)\n            keys(x.left, queue, lo, hi);\n        if (cmplo <= 0 && cmphi >= 0)\n            queue.enqueue(x.key);\n        if (cmphi > 0)\n            keys(x.right, queue, lo, hi);\n    }\n\n    public int size(Key lo, Key hi) {\n        if (lo == null)\n            throw new IllegalArgumentException();\n        if (hi == null)\n            throw new IllegalArgumentException();\n\n        if (lo.compareTo(hi) > 0)\n            return 0;\n        if (contains(hi))\n            return rank(hi) - rank(lo) + 1;\n        else\n            return rank(hi) - rank(lo);\n    }\n\n    // 余下的检查红黑树完整性的代码 略；\n}\n```\n\n\n","tags":["算法"]},{"title":"二叉查找树","url":"%2F2019%2F10%2F03%2F%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%2F","content":"\n二叉查找树是由节点和链接组成的数据结构，其中每个节点只有唯一的父节点(根节点没有父节点)，每个节点最多有两个链接，分别指向左右子节点。左右子节点也可以看成是另一颗树的根节点。\n二叉查找树的每个节点中存储着一个Comparable的键和相关联的值。\n以上就是二叉查找树的结构构成。\n其还有以下一些特点：\n**每个节点中的键都大于其左子树中的任意节点中的键**\n**每个节点中的键都小于其右子树中的任意节点中的键**\n**最底层的节点一定左右子树为空**\n**最小节点的左子树为空**\n**最大节点的右子树为空**\n二叉查找树的java实现中，查找方法get，会先将给定的key和二叉查找树根节点的key进行比较，小于则在根节点的左子树中继续查找，直至找到相等的key或者返回null为止。大于则在根节点的右子树中继续查找。给定的key等于节点的key时，则直接返回该节点。\n\n插入方法put，也会先将给定的key和二叉查找树根节点的key比较，小于则将给定的key-val放置在根节点的左子树中，大于则放置在根节点的右子树中，若等于则直接更新该节点的val值。\n\n删除最小节点的方法deleteMin，会在根节点的左子树中查找最小的节点，该节点不存在左子树，删除时将指向该节点的链接指向该节点的右子树，若该节点的右子树不存在，则指向null。而该节点因为没有被链接引用，会被垃圾回收。\n\n删除最大节点的方法deleteMax，会在根节点的右子树中查找最大的节点，该节点不存在右子树，删除时将指向该节点的链接指向该节点的左子树，若该节点的左子树不存在，则指向null。而该节点因为没有被链接引用，最终会被垃圾回收。\n\n删除任意节点的方法delete，会根据节点类型的不同，分三种情况处理。\n当然一开始需要找到该节点。查找方法和get方法类似，即和根节点的key进行比较，若小于根节点，则在左子树中继续查找；若大于根节点，则在右子树中查找。\n若查找，到达二叉查找树的叶子节点处，仍然没有找到和给定key相等的key则树中不存在该节点，返回null。\n若找到和给定key相等的节点，则：\n1. 若该节点只有左节点时，则将指向该节点的链接指向左节点。\n2. 若该节点只有右节点时，则将指向该节点的链接指向右节点。\n3. 若该节点存在左右子树时，此时需要在其右子树中找一个后继节点替换到该节点位置，以保证二叉查找树的有序。\n具体步骤如下：\n1).先将指向将被删除的节点x的链接保存在t中\n2).将x指向它的后继节点，即右子树中最小的节点min(t.right)\n3).x的右链接指向deleteMin(t.right)\n4).x的左链接指向t.left\n\n找到小于等于给定键的最大节点的floor，则依据以下规则判断：\n先将给定键key与根节点的key进行比较，当小于根节点时，则小于等于给定key的节点一定在根节点的左子树中。若大于根节点，则只有当右子树中存在小于等于给定key的节点，否则小于等于给定key的节点就是根节点。\n\n而找到大于等于给定键的最小节点的ceiling，则依据以下规则判断：\n先将给定key和根节点的key进行比较，当大于根节点时，则大于等于给定key的节点一定在右子树中。若小于根节点，则只有左子树中存在大于等于给定key的节点，否则大于等于给定key的最小节点就是根节点。\n\n其余的方法的实现，都不是很复杂。可以直接参考以下java实现：\n\n```java\nimport java.util.NoSuchElementException;\n\npublic class BST<Key extends Comparable<Key>, Value> {\n    private Node root;\n\n    private class Node {\n        private Key key;\n        private Value val;\n        private Node left;\n        private Node right;\n        private int size;\n\n        public Node(Key key, Value val, int size) {\n            this.key = key;\n            this.val = val;\n            this.size = size;\n        }\n    }\n\n    public BST() {\n    }\n\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    public int size() {\n        return size(root);\n    }\n\n    private int size(Node x) {\n        if (x == null)\n            return 0;\n        else\n            return x.size;\n    }\n\n    public boolean contains(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to contains() is null\");\n        return get(key) != null;\n    }\n\n    // 获取给定key的val\n    public Value get(Key key) {\n        return get(root, key);\n    }\n\n    private Value get(Node x, Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"call get() with a null key\");\n        if (x == null)\n            return null;\n        int cmp = key.compareTo(x.key);\n        if (cmp < 0)\n            return get(x.left, key);\n        if (cmp > 0)\n            return get(x.right, key);\n        else\n            return x.val;\n    }\n\n    // 插入给定的键值对\n    public void put(Key key, Value val) {\n        if (key == null)\n            throw new IllegalArgumentException(\"call put() with a null key\");\n        if (val == null) {\n            delete(key);\n            return;\n        }\n        root = put(root, key, val);\n        // 断言 assert\n    }\n\n    private Node put(Node x, Key key, Value val) {\n        if (x == null)\n            return new Node(key, val, 1);\n        int cmp = key.compareTo(x.key);\n        if (cmp < 0)\n            x.left = put(x.left, key, val);\n        if (cmp > 0)\n            x.right = put(x.right, key, val);\n        else\n            x.val = val;\n        x.size = 1 + size(x.left) + size(x.right);\n        return x;\n    }\n\n    // 删除最小键\n    public void deleteMin() {\n        if (isEmpty())\n            throw new NoSuchElementException(\"Symbol table underflow\");\n        root = deleteMin(root);\n        // assert\n    }\n\n    private Node deleteMin(Node x) {\n        if (x.left == null)// 最终遇到某个节点的左链接为空\n            return x.right;// 返回该节点的右链接 赋值给该节点父节点的左连接，也就是链接到此节点的链接\n        x.left = deleteMin(x.left);// 递归的搜寻左子树\n        x.size = size(x.left) + size(x.right) + 1;\n        return x;\n    }\n\n    // 删除最大键\n    public void deleteMax() {\n        if (isEmpty())\n            throw new NoSuchElementException(\"Symbol table underflow\");\n        root = deleteMax(root);\n        // assert\n    }\n\n    private Node deleteMax(Node x) {\n        if (x.right == null) {\n            return x.left;\n        }\n        x.right = deleteMax(x.right);\n        x.size = size(x.right) + size(x.left) + 1;\n        return x;\n    }\n\n    // 删除键\n    public void delete(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"calls delete() with a null key\");\n        root = delete(root, key);\n        // assert\n    }\n\n    private Node delete(Node x, Key key) {\n        if (x == null)\n            return null;\n        int cmp = key.compareTo(x.key);\n        if (cmp < 0)\n            x.left = delete(x.left, key);\n        else if (cmp > 0)\n            x.right = delete(x.right, key);\n        else {\n            // 节点有单个子节点\n            if (x.right == null)\n                return x.left;\n            if (x.left == null)\n                return x.right;\n            // 节点有两个子节点\n            Node t = x;// 将指向即将被删除的节点的链接保存在t里\n            x = min(t.right);// 将指向后继节点的链接保存在x里\n            x.right = deleteMin(t.right);// 必然会删除x指向的结点，并返回新的有序的子树\n            x.left = t.left;\n        }\n        x.size = size(x.left) + size(x.right) + 1;\n        return x;\n    }\n\n    // 找到最小的键\n    public Key min() {\n        if (isEmpty())\n            throw new IllegalArgumentException(\"calls min() with empty symbol table\");\n        return min(root).key;\n    }\n\n    private Node min(Node x) {\n        if (x.left == null)\n            return x;\n        else\n            return min(x.left);\n    }\n\n    // 找到最大的键\n\n    public Key max() {\n        if (isEmpty())\n            throw new IllegalArgumentException(\"calls max() with empty symbol table\");\n        return max(root).key;\n    }\n\n    private Node max(Node x) {\n        if (x.right == null)\n            return x;\n        else\n            return max(x.right);\n    }\n\n    // 返回<=给定键的最大键\n    public Key floor(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to floor() is null\");\n        if (isEmpty())\n            throw new NoSuchElementException(\"calls floor() with empty symbol table\");\n        Node x = floor(root, key);\n        if (x == null)\n            return null;\n        else\n            return x.key;\n    }\n\n    private Node floor(Node x, Key key) {\n        if (x == null)\n            return null;// x不存在的情况\n        int cmp = key.compareTo(x.key);// 比较\n        if (cmp == 0)\n            return x;// 相等\n        if (cmp < 0)\n            return floor(x.left, key);// 小于\n        Node t = floor(x.right, key);// 大于\n        if (t != null)\n            return t;\n        else\n            return x;\n    }\n\n    // 返回>=给定键的最小键\n\n    public Key ceiling(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to ceiling() is null\");\n        if (isEmpty())\n            throw new NoSuchElementException(\"calls ceiling() with empty symbol table\");\n        Node x = ceiling(root, key);\n        if (x == null)\n            return null;\n        else\n            return x.key;\n    }\n\n    private Node ceiling(Node x, Key key) {\n        if (x == null)\n            return null;// x不存在\n        int cmp = key.compareTo(x.key);// 比较\n        if (cmp == 0)\n            return x;// 等于\n        if (cmp < 0) {// 小于\n            Node t = ceiling(x.left, key);\n            if (t != null)\n                return t;\n            else\n                return x;\n        }\n        return ceiling(x.right, key);// 大于\n    }\n\n    // 返回给定排名的键\n    public Key select(int k) {\n        if (k < 0 || k >= size())\n            throw new IllegalArgumentException(\"argument to select() is invalid: \" + k);\n        Node x = select(root, k);\n        return x.key;\n    }\n\n    private Node select(Node x, int k) {\n        if (x == null)\n            return null;\n        int t = size(x.left);\n        if (t > k)\n            return select(x.left, k);\n        else if (t < k)\n            return select(x.right, k - t - 1);\n        else\n            return x;\n    }\n\n    // 返回符号表中小于给定键的键的数量\n    public int rank(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to rank() is null\");\n        return rank(key, root);\n    }\n\n    private int rank(Key key, Node x) {\n        if (x == null)\n            return 0;\n        int cmp = key.compareTo(x.key);\n        if (cmp < 0)\n            return rank(key, x.left);\n        else if (cmp > 0)\n            return 1 + size(x.left) + rank(key, x.right);\n        else\n            return size(x.left);\n    }\n\n    public Iterable<Key> keys() {\n        if (isEmpty())\n            return new Queue<Key>();\n        return keys(min(), max());\n    }\n\n    public Iterable<Key> keys(Key lo, Key hi) {\n        if (lo == null)\n            throw new IllegalArgumentException(\"first argument to keys() is null\");\n        if (hi == null)\n            throw new IllegalArgumentException(\"second argument to keys() is null\");\n\n        Queue<Key> queue = new Queue<Key>();\n        keys(root, queue, lo, hi);\n        return queue;\n    }\n\n    private void keys(Node x, Queue<Key> queue, Key lo, Key hi) {\n        if (x == null)\n            return;\n        int cmplo = lo.compareTo(x.key);\n        int cmphi = hi.compareTo(x.key);\n        if (cmplo < 0)\n            keys(x.left, queue, lo, hi);\n        if (cmplo <= 0 && cmphi >= 0)\n            queue.enqueue(x.key);\n        if (cmphi > 0)\n            keys(x.right, queue, lo, hi);\n    }\n\n    public int size(Key lo, Key hi) {\n        if (lo == null)\n            throw new IllegalArgumentException(\"first argument to size() is null\");\n        if (hi == null)\n            throw new IllegalArgumentException(\"second argument to size() is null\");\n\n        if (lo.compareTo(hi) > 0)\n            return 0;\n        if (contains(hi))\n            return rank(hi) - rank(lo) + 1;\n        else\n            return rank(hi) - rank(lo);\n    }\n\n    public int height() {\n        return height(root);\n    }\n\n    private int height(Node x) {\n        if (x == null)\n            return -1;\n        return 1 + Math.max(height(x.left), height(x.right));\n    }\n\n    public Iterable<Key> levelOrder() {\n        Queue<Key> keys = new Queue<Key>();\n        Queue<Node> queue = new Queue<Node>();\n        queue.enqueue(root);\n        while (!queue.isEmpty()) {\n            Node x = queue.dequeue();\n            if (x == null)\n                continue;\n            keys.enqueue(x.key);\n            queue.enqueue(x.left);\n            queue.enqueue(x.right);\n        }\n        return keys;\n    }\n\n    // check integrity of BST data structure\n    private boolean check() {\n        if (!isBST())\n            StdOut.println(\"Not in symmetric order\");\n        if (!isSizeConsistent())\n            StdOut.println(\"Subtree counts not consistent\");\n        if (!isRankConsistent())\n            StdOut.println(\"Ranks not consistent\");\n        return isBST() && isSizeConsistent() && isRankConsistent();\n    }\n\n    private boolean isBST() {\n        return isBST(root, null, null);\n    }\n\n    private boolean isBST(Node x, Key min, Key max) {\n        if (x == null)\n            return true;\n        if (min != null && x.key.compareTo(min) <= 0)\n            return false;\n        if (max != null && x.key.compareTo(max) >= 0)\n            return false;\n        return isBST(x.left, min, x.key) && isBST(x.right, x.key, max);\n    }\n\n    private boolean isSizeConsistent() {\n        return isSizeConsistent(root);\n    }\n\n    private boolean isSizeConsistent(Node x) {\n        if (x == null)\n            return true;\n        if (x.size != size(x.left) + size(x.right) + 1)\n            return false;\n        return isSizeConsistent(x.left) && isSizeConsistent(x.right);\n    }\n\n    private boolean isRankConsistent() {\n        for (int i = 0; i < size(); i++)\n            if (i != rank(select(i)))\n                return false;\n        for (Key key : keys())\n            if (key.compareTo(select(rank(key))) != 0)\n                return false;\n        return true;\n    }\n}\n```\n","tags":["算法"]},{"title":"基于有序数组的二分查找","url":"%2F2019%2F10%2F03%2F%E5%9F%BA%E4%BA%8E%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F","content":"\n二分查找采用的是双数组方式，将键和值分开存储。在Java的实现中rank方法是实现其他方法的关键之一。\n实现如下：\n\n```java\nimport java.util.NoSuchElementException;\n\npublic class BinarySearchST<Key extends Comparable<Key>, Value> {\n    private static final int INI_CAPACITY = 2;\n    private Key[] keys;\n    private Value[] vals;\n    private int n = 0;\n\n    public BinarySearchST() {\n        this(INI_CAPACITY);\n    }\n\n    public BinarySearchST(int capacity) {\n        keys = (Key[]) new Comparable[capacity];\n        vals = (Value[]) new Object[capacity];\n    }\n\n    private void resize(int capacity) {// 扩大容量\n        Key[] tempk = (Key[]) new Comparable[capacity];\n        Value[] tempv = (Value[]) new Object[capacity];\n        for (int i = 0; i < n; i++) {\n            tempk[i] = keys[i];\n            tempv[i] = vals[i];\n        }\n        vals = tempv;\n        keys = tempk;\n    }\n\n    public int size() {\n        return n;\n    }\n\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    public boolean contains(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to contains() is null\");\n        return get(key) != null;\n    }\n\n    public Value get(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to get() is null\");\n        if (isEmpty())\n            return null;\n        int i = rank(key);\n        if (i < n && keys[i].compareTo(key) == 0)\n            return vals[i];\n        return null;\n    }\n\n    public int rank(Key key) {// 返回小于给定键的键的数量\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to rank() is null\");\n\n        int lo = 0, hi = n - 1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            int cmp = key.compareTo(keys[mid]);\n            if (cmp < 0)\n                hi = mid - 1;\n            else if (cmp > 0)\n                lo = mid + 1;\n            else\n                return mid; // 命中查找\n        }\n        return lo;// 当lo>=hi时，若key > keys[mid]的值，则返回lo\n    }\n\n    public void put(Key key, Value val) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to put() is null\");\n        if (val == null) {\n            delete(key);\n            return;\n        }\n        int i = rank(key);\n        if (i < n && keys[i].compareTo(key) == 0) {\n            vals[i] = val;\n            return;\n        }\n\n        if (n == keys.length)\n            resize(2 * keys.length);\n\n        for (int j = n; j > i; j--) {// 整体右移\n            keys[j] = keys[j - 1];\n            vals[j] = vals[j - 1];\n        }\n        keys[i] = key;\n        vals[i] = val;\n        n++;\n\n        assert check();\n    }\n\n    public void delete(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to delete() is null\");\n        if (isEmpty())\n            return;\n\n        int i = rank(key);\n\n        if (i == n || keys[i].compareTo(key) != 0) {\n            return;\n        }\n\n        for (int j = i; j < n - 1; j++) {// 整体左移动\n            keys[j] = keys[j + 1];\n            vals[j] = vals[j + 1];\n        }\n        n--;\n        keys[n] = null;\n        vals[n] = null;\n\n        if (n > 0 && n == keys.length / 4)\n            resize(keys.length / 2); // 容量的变化\n        assert check();\n    }\n\n    public void deleteMin() {\n        if (isEmpty())\n            throw new NoSuchElementException(\"Symbol table underflow error\");\n        delete(min());\n    }\n\n    public Key min() {\n        if (isEmpty())\n            throw new NoSuchElementException(\"called min() with empty symbol table\");\n        return keys[0];\n    }\n\n    public void deleteMax() {\n        if (isEmpty())\n            throw new NoSuchElementException(\"Symbol table underflow error\");\n        delete(max());\n    }\n\n    public Key max() {\n        if (isEmpty())\n            throw new NoSuchElementException(\"called max() with empty symbol table\");\n        return keys[n - 1];\n    }\n\n    public Key select(int k) {\n        if (k < 0 || k >= size()) {\n            throw new IllegalArgumentException(\"called select() with invalid argument: \" + k);\n        }\n        return keys[k];\n    }\n\n    public Key floor(Key key) {// 返回符号表中<=给定键的最大key\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to floor() is null\");\n        int i = rank(key);\n        if (i < n && key.compareTo(keys[i]) == 0)\n            return keys[i];\n        if (i == 0)\n            return null;\n        else\n            return keys[i - 1];\n    }\n\n    public Key ceiling(Key key) {// 返回符号表中>=给定键的最小key\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to ceiling() is null\");\n        int i = rank(key);\n        if (i == n)\n            return null;\n        else\n            return keys[i];\n    }\n\n    public int size(Key lo, Key hi) {// 计算指定两个键之间的键的数量\n        if (lo == null)\n            throw new IllegalArgumentException(\"first argument to size() is null\");\n        if (hi == null)\n            throw new IllegalArgumentException(\"second argument to size() is null\");\n        if (lo.compareTo(hi) > 0)\n            return 0;\n        if (contains(hi))\n            return rank(hi) - rank(lo) + 1;\n        else\n            return rank(hi) - rank(lo);\n    }\n\n    public Iterable<Key> keys() {\n        return keys(min(), max());\n    }\n\n    public Iterable<Key> keys(Key lo, Key hi) {\n        if (lo == null)\n            throw new IllegalArgumentException(\"first argument to size() is null\");\n        if (hi == null)\n            throw new IllegalArgumentException(\"second argument to size() is null\");\n\n        Queue<Key> queue = new Queue<Key>();\n        if (lo.compareTo(hi) > 0)\n            return queue;\n        for (int i = rank(lo); i < rank(hi); i++) {\n            queue.enqueue(keys[i]);\n        }\n        if (contains(hi))\n            queue.enqueue(keys[rank(hi)]);\n        return queue;\n    }\n\n    // check internal invarants\n    public boolean check() {\n        return isSort() && rankCheck();\n    }\n\n    private boolean isSort() {\n        for (int i = 1; i < size(); i++) {\n            if (keys[i].compareTo(keys[i - 1]) < 0)\n                return false;\n        }\n        return true;\n    }\n\n    private boolean rankCheck() {\n        for (int i = 0; i < size(); i++)\n            if (i != rank(select(i)))\n                return false;\n        for (int i = 0; i < size(); i++)\n            if (keys[i].compareTo(select(rank(keys[i]))) != 0)\n                return false;\n        return true;\n    }\n}\n```\n\n","tags":["算法"]},{"title":"改变习惯--《习惯的力量》","url":"%2F2019%2F10%2F03%2F%E6%94%B9%E5%8F%98%E4%B9%A0%E6%83%AF-%E3%80%8A%E4%B9%A0%E6%83%AF%E7%9A%84%E5%8A%9B%E9%87%8F%E3%80%8B%2F","content":"要改变自己的习惯，需找到习惯回路的三个部分：暗示、惯常行为和奖赏。\n通常渴求驱使行为，行为带来奖赏，奖赏满足渴求。\n\n第一步 找到惯常行为\n惯常行为通常很明显，就是你想要改变的行为。\n\n第二步 用奖赏做实验 找到奖赏背后的渴求\n不同的行为带来不同的奖赏。\n尝试4～5种不同的行为，在每次活动之后，拿出笔写下能想到的三个词，然后定下15分钟的闹钟，等闹钟结束后问问自己是否还有想作出原先惯常行为的冲动，若有则该行为的奖赏对应的渴求并不属于原先习惯。反之则是原先习惯想满足的东西。\n\n第三步 分隔暗示\n几乎所有的习惯性暗示都可以分为五类：地点、时间、情绪状态、其他人、之前紧挨着的动作。\n所以要找到某个习惯的暗示，请在这一冲动出现前写下5样东西：你在哪？现在几点？你的情绪怎样？周围有谁？在这个冲动出现之前做了什么？\n连续几天记录，就会发现暗示是什么。\n\n第四步 制定计划\n在了解习惯回路三要素之后，通过围绕暗示设计，选择能够满足你所渴求的奖赏的行为，不断执行，就可以改善习惯。\n习惯是大脑自动遵循的行为模式，即看到暗示，做出惯常行为，得到奖赏。\n调整这个模式最容易的方式是制定计划。\n即在暗示出现时，每次都做计划中所定的与惯常行为不同的行为。一开始执行并不一定顺利，但每次都强迫自己按照计划去做，最终会改变这一习惯。\n即保留暗示和奖赏背后对应的渴求，改变惯常行为。\n了解习惯的背后真正需要的是什么，才可以在暗示出现时，作出不同的行为，从而满足同样的心理需求，但得到不一样的现实结果。如何做选择完全在于自己。\n习惯却也不仅限于行为习惯，也包括思维习惯。\n","tags":["心理"]},{"title":"符号表和顺序查找","url":"%2F2019%2F10%2F03%2F%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%2F","content":"\n符号表是一种用来存储数据的抽象数据结构。其最主要的目的是将一个键和一个值联系起来，并提供插入新的键值对和直接通过键查找到相应值的功能。\n\n符号表的实现，首先可以使用一个简单的链表。每个节点表示一个键值对。\n其Java实现如下：\n其中get和put方法均是通过遍历链表的方式来进行相关操作。\n```java\npublic class SequentialSearchST<Key, Value> {\n    private int n;// 键值对数量\n    private Node first;\n\n    private class Node {// 内部类\n        private Key key;\n        private Value val;\n        private Node next;\n\n        public Node(Key key, Value val, Node next) {\n            this.key = key;\n            this.val = val;\n            this.next = next;\n        }\n    }\n\n    public SequentialSearchST() {\n    }\n\n    public int size() {\n        return n;\n    }\n\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    public boolean contains(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to contains() is null\");\n        return get(key) != null;\n    }\n\n    public Value get(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to get() is null\");\n        for (Node x = first; x != null; x = x.next) {\n            if (key.equals(x.key))\n                return x.val;\n        }\n        return null;\n    }\n\n    public void put(Key key, Value val) {\n        if (key == null)\n            throw new IllegalArgumentException(\"first argument to put() is null\");\n        if (val == null) {\n            delete(key);\n            return;\n        }\n        for (Node x = first; x != null; x = x.next) {\n            if (key.equals(x.key)){\n                x.val = val;\n                return;\n            }\n        }\n        first = new Node(key, val, first);\n        n++;\n    }\n\n    public void delete(Key key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"argument to delete() is null\");\n        first = delete(first, key);\n    }\n\n    private Node delete(Node x, Key key) {\n        if (x == null)\n            return null;\n        if (key.equals(x.key)) {\n            n--;\n            return x.next;\n        }\n        x.next = delete(x.next, key);\n        return x;\n    }\n\n    public Iterable<Key> keys() {\n        Queue<Key> queue = new Queue<Key>();\n        for (Node x = first; x != null; x = x.next) {\n            queue.enqueue(x.key);\n        }\n        return queue;\n    }\n\n}\n```\n\n\n","tags":["算法"]},{"title":"堆排序","url":"%2F2019%2F09%2F27%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F","content":"\n堆排序的基本思想是：将一个无序数组排列成一个堆，然后将最大元素和末尾元素交换，并减小堆的长度，然后将剩下的元素重新排列成一个堆，继续将最大元素和末尾元素交换，减小堆长度。如此反复，最终得到一个有序序列(降序)。\nJava实现：\n\n```java\npublic class Heap {\n    private Heap() {\n    }\n\n    public static void sort(Comparable[] pq) {\n        int n = pq.length;\n        for (int k = n / 2; k >= 1; k--) {\n            sink(pq, k, n);// 构造堆\n        }\n        while (n > 1) {\n            exch(pq, 1, n--);// 将数组最大元素和末尾元素交换，然后删除\n            sink(pq, 1, n);// 保持堆有序\n        }\n    }\n\n    private static void sink(Comparable[] pq, int k, int n) {\n        while (2 * k <= n) {\n            int j = 2 * k;\n            if (j < n && less(pq, j, j + 1))\n                j++;\n            if (!less(pq, k, j))\n                break;\n            exch(pq, k, j);\n            k = j;\n        }\n    }\n\n    // helper functions\n    private static boolean less(Comparable[] pq, int i, int j) {\n        return pq[i - 1].compareTo(pq[j - 1]) < 0;\n    }\n\n    private static void exch(Object[] pq, int i, int j) {\n        Object t = pq[i - 1];\n        pq[i - 1] = pq[j - 1];\n        pq[j - 1] = t;\n    }\n}\n```\n\n","tags":["算法"]},{"title":"索引优先队列","url":"%2F2019%2F09%2F26%2F%E7%B4%A2%E5%BC%95%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%2F","content":"\n在某些应用场景下，引用进入优先队列中的元素是必要的。做到这点的方式是给每一个元素都加一个索引。\n以下的Java实现中，有几个功能不同的数组。\n搞清楚这几个数组的功能，也就能理解实现中的代码含义。\n若数据有误，敬请指正。\n\n```java\nimport java.util.NoSuchElementException;\nimport java.util.Iterator;\n\npublic class IndexMaxPQ<Key extends Comparable<Key>> implements Iterable<Integer> {\n    private int n;// pq中的元素数量\n    private int[] pq;// 优先队列，其中存储的是元素在Key数组中的索引\n    // key数组索引对应的元素，在优先队列中的索引位置,\n    // 在keys数组中的元素被改变时，快速找到该元素在优先队列中的位置，进行上浮和下沉操作以保持堆有序\n    private int[] qp;\n    private Key[] keys;// 实际存放元素的数组\n\n    // initializes\n    public IndexMaxPQ(int maxN) {\n        if (maxN < 0)\n            throw new IllegalArgumentException();\n        n = 0;\n        keys = (Key[]) new Comparable[maxN + 1];\n        pq = new int[maxN + 1];\n        qp = new int[maxN + 1];\n        for (int i = 0; i <= maxN; i++) {\n            qp[i] = -1;\n        }\n    }\n\n    public boolean isEmpty() {\n        return n == 0;\n    }\n\n    public boolean contains(int i) {\n        return qp[i] != -1;\n    }\n\n    public int size() {\n        return n;\n    }\n\n    public void insert(int i, Key key) {// 插入\n        if (contains(i))\n            throw new NoSuchElementException(\"index is already in the priority queue\");\n        n++;\n        qp[i] = n;// keys[i]在优先队列中的索引\n        pq[n] = i;// 优先队列索引n处存放元素在keys[]中的索引\n        keys[i] = key;// 存放数据\n        swin(n);// 上浮\n    }\n\n    public int MaxIndex() {// 返回最大元素索引\n        if (n == 0)\n            throw new NoSuchElementException(\"priority queue underflow\");\n        return pq[1];\n    }\n\n    public Key maxKey() {// 返回最大元素\n        if (n == 0)\n            throw new NoSuchElementException(\"priority queue underflow\");\n        return keys[pq[1]];\n    }\n\n    public int delMax() {// 删除最大值\n        if (n == 0)\n            throw new NoSuchElementException(\"Priority queue underflow\");\n        int max = pq[1];\n        exch(1, n--);\n        sink(1);\n\n        assert pq[n + 1] == max;\n        qp[max] = -1;\n        keys[max] = null;\n        pq[n + 1] = -1;\n        return max;\n    }\n\n    public Key keyOf(int i) {// 返回i对应的值\n        if (!contains(i))\n            throw new NoSuchElementException(\"index is not in the priority queue\");\n        else\n            return keys[i];\n    }\n\n    public void changeKey(int i, Key key) {// 修改i位置的值为key\n        if (!contains(i))\n            throw new NoSuchElementException(\"index is not in the priority queue\");\n        keys[i] = key;\n        swin(qp[i]);// 在优先队列中的位置\n        sink(qp[i]);\n    }\n\n    public void increaseKey(int i, Key key) {// 修改i位置的值为key key大于原值\n        if (!contains(i))\n            throw new NoSuchElementException(\"index is not in the priority queue\");\n        if (keys[i].compareTo(key) >= 0)\n            throw new IllegalArgumentException(\n                    \"Calling increaseKey() with given argument would not strictly increase the key\");\n        keys[i] = key;\n        swin(qp[i]);// 在优先队列中的位置\n    }\n\n    public void decreaseKey(int i, Key key) {// 修改i位置的值为key key小于原值\n        if (!contains(i))\n            throw new NoSuchElementException(\"index is not in the priority queue\");\n        if (keys[i].compareTo(key) <= 0)\n            throw new IllegalArgumentException(\n                    \"Calling decreaseKey() with given argument would not strictly decrease the key\");\n        keys[i] = key;\n        sink(qp[i]);// 在优先队列中的位置\n    }\n\n    public void delete(int i) {// 删除i位置的元素\n        if (!contains(i))\n            throw new NoSuchElementException(\"inde is not in the priority queue\");\n        int index = qp[i];\n        exch(index, n--);\n        swin(index);\n        sink(index);\n        keys[i] = null;\n        qp[i] = -1;\n    }\n    // helper functions\n\n    private boolean less(int i, int j) {\n        return keys[pq[i]].compareTo(keys[pq[j]]) < 0;\n    }\n\n    private void exch(int i, int j) {\n        int t = pq[i];\n        pq[i] = pq[j];\n        pq[j] = t;\n        qp[pq[i]] = i;\n        qp[pq[j]] = j;\n    }\n\n    private void swin(int k) {\n        while (k > 1 && less(k / 2, k)) {\n            exch(k / 2, k);\n            k /= 2;\n        }\n    }\n\n    private void sink(int k) {\n        while (2 * k < n) {\n            int j = 2 * k;\n            if (j < n && less(j, j + 1))\n                j++;\n            if (!less(k, j))\n                break;\n            exch(k, j);\n            k = j;\n        }\n    }\n\n    public Iterator<Integer> iterator() {\n        return new HeapIterator();\n    }\n\n    private class HeapIterator implements Iterator<Integer> {\n\n        private IndexMaxPQ<Key> copy;\n\n        public HeapIterator() {\n            copy = new IndexMaxPQ<Key>(pq.length - 1);\n            for (int i = 1; i <= n; i++)\n                copy.insert(pq[i], keys[pq[i]]);\n        }\n\n        public boolean hasNext() {\n            return !copy.isEmpty();\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Integer next() {\n            if (!hasNext())\n                throw new NoSuchElementException();\n            return copy.delMax();\n        }\n    }\n}\n```\n\n","tags":["算法"]},{"title":"优先队列","url":"%2F2019%2F09%2F25%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%2F","content":"\n优先队列，是一种抽象数据结构类型。其支持删除最大(小)元素和插入元素操作。\n其存在场景经常是：收集部分元素，处理这些元素中键值最大(小)的元素，再收集一部分元素，再处理这些元素中最大(小)的元素。实际的场景例如：任务调度\n而这里实现优先队列这种数据结构的基础是二叉堆。\n\n下面详细说明什么是二叉堆。\n\n首先，当一颗二叉树的每个节点都大于等于它的两个子节点时，它被称为堆有序。\n堆有序的二叉树中最大节点是根节点。\n\n其次，一颗二叉树能成为完全二叉树，必须满足以下条件：\n在二叉树的深度为h的条件下，除了第h层以外，1~h-1层的节点数已达到最大，h层的节点都连续存在于最左边。\n\n最后，二叉堆是什么呢？二叉堆是一组能够使用堆有序的完全二叉树表示的元素，并在数组中按照层级存储(不使用数组的第一个位置)。\n\n二叉堆的堆有序可能会在某个元素发生变化之后被破坏，此时就要进行堆有序化的操作。\n当二叉堆的某个元素变得比父节点大时，就需要和父元素交换，然后再次比较父元素位置所对应的父元素，最终停留在适合的位置，这个过程被称为上浮。\n当二叉堆的某个元素变得比其子元素小时，其需要和其子元素进行交换，然后需要再次和该位置的子元素进行比较，最终停留在适合的位置，这个过程被称为下沉。\n插入元素，一般将新元素放在数组的末尾，然后进行上浮操作，增加堆的大小。\n删除最大元素，将根元素删除后，将数组末尾的元素放在根节点位置，进行下沉操作，减小堆的大小。\nJava的实现如下：\n\n```java\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\npublic class MaxPQ<Key> implements Iterable<Key> {\n    private Key[] pq; // 存储元素的数组\n    private int n; // 优先队列中的元素数量\n    private Comparator<Key> comparator;\n\n    // Construction functions\n\n    public MaxPQ(int initCapacity) {\n        pq = (Key[]) new Object[initCapacity + 1];\n        n = 0;\n    }\n\n    public MaxPQ() {\n        this(1);\n    }\n\n    public MaxPQ(int initCapacity, Comparator<Key> comparator) {\n        this.comparator = comparator;\n        pq = (Key[]) new Object[initCapacity + 1];\n        n = 0;\n    }\n\n    public MaxPQ(Comparator<Key> comparator) {\n        this(1, comparator);\n    }\n\n    public MaxPQ(Key[] keys) {\n        n = keys.length;\n        pq = (Key[]) new Object[keys.length + 1];\n        for (int i = 0; i < n; i++) {\n            pq[i + 1] = keys[i];\n        }\n        for (int k = n / 2; k >= 1; k--) {\n            sink(k);\n        }\n        assert isMaxHeap();\n    }\n\n    public boolean isEmpty() {\n        return n == 0;\n    }\n\n    public int size() {\n        return n;\n    }\n\n    public Key max() {\n        if (isEmpty())\n            throw new NoSuchElementException(\"Priority queue underflow\");\n        return pq[1];\n    }\n\n    private void resize(int capacity) {//调整队列长度\n        assert capacity > n;\n        Key[] t = (Key[]) new Object[capacity];\n        for (int i = 1; i <= n; i++) {\n            t[i] = pq[i];\n        }\n        pq = t;\n    }\n\n    public void insert(Key x) {\n        if(n==pq.length-1) resize(2*pq.length);\n        pq[++n] = x;//将节点放在数组的最后\n        swin(n);//上浮节点，以保持堆有序\n        assert isMaxHeap();\n    }\n\n    public Key delMax() {\n        if (isEmpty())\n            throw new NoSuchElementException(\"Priority queue underflow\");\n        Key max = pq[1]; // 获取优先队列的最大元素\n        exch(1, n--);// 将数组最后的一个子节点与根节点交换, 之后减小n的大小，即删除了最大元素\n        sink(1);// 下沉交换后的节点，使数组达到堆有序\n        pq[n + 1] = null;// 防止删除的节点 游离 和 垃圾回收\n        if ((n > 0) && (n == (pq.length - 1) / 4))\n            resize(pq.length / 2);// 减小数组的大小 减小内存占用\n        assert isMaxHeap();\n        return max;\n    }\n\n    // helper functions\n    private void swin(int k) {//上浮节点\n        while (k > 1 && less(k / 2, k)) {//比较节点与父节点的大小\n            exch(k, k / 2);//交换\n            k /= 2;\n        }\n    }\n\n    private void sink(int k) {//下沉\n        while (2 * k <= n) {\n            int j = 2 * k;\n            if (j < n && less(j, j + 1))//比较两个子节点的大小\n                j++;\n            if (!less(k, j))//当\b索引k位置的节点大于两个字节点时，中断\n                break;\n            exch(k, j);//否则交换\n            k = j;\n        }\n    }\n\n    private boolean less(int i, int j) {\n        if (comparator == null) {\n            return ((Comparable<Key>) pq[i]).compareTo(pq[j]) < 0;\n        } else {\n            return comparator.compare(pq[i], pq[j]) < 0;\n        }\n    }\n\n    private void exch(int i, int j) {\n        Key t = pq[i];\n        pq[i] = pq[j];\n        pq[j] = t;\n    }\n\n    public boolean isMaxHeap() {\n        return isMaxHeap(1);\n    }\n\n    private boolean isMaxHeap(int k) {\n        if (k > n)\n            return true;\n        int left = 2 * k;\n        int right = 2 * k + 1;\n        if (left <= n && less(k, left))\n            return false;\n        if (right <= n && less(k, right))\n            return false;\n        return isMaxHeap(left) && isMaxHeap(right);\n    }\n\n    public Iterator<Key> iterator() {\n        return new HeapIterator();\n    }\n\n    private class HeapIterator implements Iterator<Key> {\n        private MaxPQ<Key> copy;\n\n        public HeapIterator() {\n            if (comparator == null)\n                copy = new MaxPQ<Key>(size());\n            else\n                copy = new MaxPQ<Key>(size(), comparator);\n            for (int i = 1; i <= n; i++) {\n                copy.insert(pq[i]);\n            }\n        }\n\n        public boolean hasNext() {\n            return !copy.isEmpty();\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Key next() {\n            if (!hasNext())\n                throw new NoSuchElementException();\n            return copy.delMax();\n        }\n    }\n}\n```\n\n","tags":["算法"]},{"title":"快速排序(二)","url":"%2F2019%2F09%2F25%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(%E4%BA%8C)%2F","content":"\n基本的快速排序，在面对有大量重复元素数组的时候，排序的速度是不够快的。\n改进的方式有几种。\n第一，对在切分过程中形成的小数组，插入排序比快速排序要快。因此，在小数组存在的情况下，在sort方法中：\n\n```java\nif(hi<=lo) return; \n=> \nif(hi<=lo+M) { \n  Insertion.sort(a,0,a.length);\n  return;\n}\n```\nM的值和系统相关，在5~15之间的任意值大多数情况下都能令人满意。\n第二，则是将子数组的一小部分元素的中位数来切分数组。\n第三，则是将数组切分为三部分，分别对应小于、等于和大于切分元素。\nJava实现如下：\n\n```java\npublic class Quick3way {\n\n    private Quick3way() {\n    }\n\n    private static void sort(Comparable[] a) {\n        StdRandom.shuffle(a);//随机化数组元素，以防止切分不均衡\n        sort(a, 0, a.length);\n        assert isSorted(a);\n    }\n\n    private static void sort(Comparable[] a, int lo, int hi) {\n        if (hi <= lo)\n            return;\n        int lt = lo, gt = hi;// lt指针 从左往右移动 gr指针从右往左移动\n        Comparable v = a[lo];// 切分元素\n        int i = lo + 1;\n        while (i <= gt) {\n            int cmp = a[i].compareTo(v);// 将数组剩余的元素和v进行比较\n            if (cmp < 0)// 小于的交换lt和i处的元素，并移动指针\n                exch(a, lt++, i++);\n            else if (cmp > 0)// 大于的交换i和gt处的元素，并移动指针\n                exch(a, i, gt--);\n            else\n                i++;// 等于的只移动i指针\n        }\n        // 递归的调用sort方法在小于v的区域和大于v的区域内\n        sort(a, lo, lt - 1);\n        sort(a, gt + 1, hi);\n        assert isSorted(a, lo, hi);\n    }\n\n    // helper functions\n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n\n    private static void exch(Object[] a, int i, int j) {\n        Object t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n    }\n\n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length - 1);\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = lo + 1; i <= hi; i++) {\n            if (less(a[i], a[i - 1]))\n                return false;\n        }\n        return true;\n    }\n\n}\n```\n\n\n","tags":["算法"]},{"title":"快速排序(一)","url":"%2F2019%2F09%2F24%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(%E4%B8%80)%2F","content":"\n快速排序可能是应用最多的排序算法。原因包括：实现简单，速度快。\n其思想是将数组分成两个子数组，当两个子数组有序了，整个数组也就有序了。\n这个算法的关键在于切分。\n切分是将数组一分为二。\n切分左侧的元素都不大于切分，切分右侧的元素都不小于切分。\n实现切分的方法是：先随意的选取一个元素当作切分元素，然后用指针 i 从数组的左端向右扫描，直至找到一个大于它的元素，再用指针 j 从数组的右端向左扫描，直至找到一个小于它的元素，然后交换这两个元素。如此继续，最终切分元素的左边都是不大于它的元素，右边都是不小于它的元素。当向左和向右扫描的两个指针相遇的时候，则将切分元素和左数组最右侧的元素交换，然后返回右指针 j 。\n排序的实现是：既然切分将数组分成了两个部分，然后继续递归的将子数组切分，最终整个数组变得有序。\nJava实现如下：\n\n```java\npublic class Quick {\n    private Quick() {\n    }\n\n    public static void sort(Comparable[] a) {\n        StdRandom.shuffle(a);//随机打乱数组元素，防止切分不平衡\n        sort(a, 0, a.length - 1);\n        assert isSorted(a);\n    }\n\n    private static void sort(Comparable[] a, int lo, int hi) {\n        if (hi <= lo)\n            return;\n        int j = partition(a, lo, hi);\n        sort(a, lo, j - 1);\n        sort(a, j + 1, hi);\n        assert isSorted(a, lo, hi);\n    }\n\n    private static int partition(Comparable[] a, int lo, int hi) {\n        int i = lo;\n        int j = hi + 1;\n        Comparable v = a[lo];// 切分元素\n        while (true) {\n            while (less(a[++i], v)) {// 找到比切分元素大的元素\n                if (i == hi)\n                    break;\n            }\n\n            while (less(v, a[--j])) {// 找到比切分元素小的元素\n                if (j == lo)\n                    break;\n            }\n\n            if (i >= j)// i不能大于j\n                break;\n            exch(a, i, j);// 交换\n        }\n\n        exch(a, lo, j);// 切分交换\n\n        return j;\n    }\n\n    private static boolean less(Comparable a, Comparable b) {\n        return a.compareTo(b) < 0;\n    }\n\n    private static void exch(Object[] a, int i, int j) {\n        Object t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n    }\n\n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length - 1);\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = 0; i <= hi; i++) {\n            if (less(a[i], a[i--]))\n                return false;\n        }\n        return true;\n    }\n}\n```\n\n","tags":["算法"]},{"title":"归并排序(二)","url":"%2F2019%2F09%2F23%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(%E4%BA%8C)%2F","content":"\n归并排序除了自顶而下的归并方式：「即将大问题分割成小问题，将小问题解决后再解决大问题」，还有另一种自底向上的归并方式。\n其思想是：先归并那些微型数组，然后再成对归并得到的子数组。如此直至归并了整个数组，排序结束。\n自底向上的归并排序适合用链表组织的数据。\n\n```java\npublic class MergeBU {\n\n    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\n        for (int k = 0; k <= hi; k++) {\n            aux[k] = a[k];\n        }\n\n        int i = lo, j = mid + 1;\n        for (int k = 0; k <= hi; k++) {\n            if (i > mid)\n                a[k] = aux[j++];\n            else if (j > hi)\n                a[k] = aux[i++];\n            else if (less(aux[j], aux[i]))\n                a[k] = aux[j++];\n            else\n                a[k] = aux[i++];\n        }\n    }\n\n    public static void sort(Comparable[] a) {\n        int n = a.length;\n        Comparable[] aux = new Comparable[n];\n        for (int len = 1; len < n; len *= 2) {// 子数组大小\n            // 子数组索引，其中lo+=len+len，表示子数组中的元素在数组中的最大索引值\n            for (int lo = 0; lo < n - len; lo += len + len) {\n                int mid = lo + len - 1;\n                int hi = Math.min(lo + len + len - 1, n - 1);\n                merge(a, aux, lo, mid, hi);\n            }\n        }\n        assert isSorted(a);\n    }\n\n    private static boolean less(Comparable a, Comparable b) {\n        return a.compareTo(b) < 0;\n    }\n\n    private static boolean isSorted(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            if (less(a[i], a[i - 1]))\n                return false;\n        }\n        return true;\n    }\n\n}\n```\n\n","tags":["算法"]},{"title":"希尔排序与归并排序(一)","url":"%2F2019%2F09%2F23%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(%E4%B8%80)%2F","content":"\n在大规模乱序数组中插入排序很慢，因为它只会交换相邻的元素。\n希尔排序是在插入排序的基础上进行修改的。\n其思想是使数组中任意间隔为h的元素有序。排序的过程类似于插入排序但使用不同的增量。\n\n```java\npublic class Shell {\n    private Shell() {\n    }\n\n    public static void sort(Comparable[] a) {\n        int n = a.length;\n        int h = 1;\n        while (h < n / 3)\n            h = 3 * h + 1;// 计算最大的间隔值\n        while (h >= 1) {\n            for (int i = h; i < n; i++) {// 以不同增量进行的插入排序\n                for (int j = i; j >= h && less(a[j], a[j - h]); j -= h) {\n                    exch(a, j, j - h);\n                }\n            }\n            assert isHsorted(a, h);\n            h /= 3;// 改变增量，使数组中的不同h-子数组有序\n        }\n        assert isSorted(a);\n    }\n\n    private static boolean less(Comparable a, Comparable b) {\n        return a.compareTo(b) < 0;\n    }\n\n    private static void exch(Object[] a, int i, int j) {\n        Object t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n    }\n\n    private static boolean isSorted(Comparable[] a) {\n        for (int i = 1; i < a.length; i++) {\n            if (less(a[i], a[i - 1]))\n                return false;\n        }\n        return true;\n    }\n\n    private static boolean isHsorted(Comparable[] a, int h) {\n        for (int i = h; i < a.length; i++) {\n            if (less(a[i], a[i - h]))\n                return false;\n        }\n        return true;\n    }\n}\n```\n\n归并排序\n思想：将数组分成两半分别排序，再将结果归并起来。\n原地归并的抽象方法，是归并算法的核心。\n自顶向下的归并，sort方法以递归的方式，将数组相邻的两个元素进行排序，在此基础上扩大归并的范围。\n\n```java\npublic class Merge {\n    private Merge() {\n    }\n\n    // 原地归并的抽象方法\n    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\n        assert isSorted(a, lo, mid);//判断数组的左边是否有序\n        assert isSorted(a, mid + 1, hi);//判断数组的右边是否有序\n\n        for (int k = lo; k <= hi; k++) {\n            aux[k] = a[k];\n        }\n        int i = lo, j = mid + 1;\n        for (int k = lo; k <= hi; k++) {\n            // 将数组分为两半，依次比较两个数组的元素，然后将较小的结果存入原数组中\n            if (i > mid)// 左边取完，继续取右边的\n                a[k] = aux[j++];\n            else if (j > hi)// 右边取完，取左边的\n                a[k] = aux[i++];\n            else if (less(aux[j], aux[i]))// 当左右两边的数组都没有取完，且右边数组的元素较小，取右边的\n                a[k] = aux[j++];\n            else// 否则取左边的\n                a[k] = aux[i++];\n        }\n        assert isSorted(a, lo, hi);\n    }\n\n    public static void sort(Comparable[] a) {\n        Comparable[] aux = new Comparable[a.length];\n        sort(a, aux, 0, a.length - 1);\n        assert isSorted(a);\n\n    }\n\n    // 自顶向下的归并排序\n    private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {\n        if (hi <= lo)\n            return;\n        int mid = lo + (hi - lo) / 2;\n        sort(a, aux, lo, mid);// 数组的左半边排序，递归\n        sort(a, aux, mid + 1, hi);// 数组的右半边排序，递归\n        merge(a, aux, lo, mid, hi);// 原地归并\n    }\n\n    private static boolean less(Comparable a, Comparable b) {\n        return a.compareTo(b) < 0;\n    }\n\n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length - 1);\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = lo + 1; i <= hi; i++) {\n            if (less(a[i], a[i - 1]))\n                return false;\n        }\n        return true;\n    }\n}\n```\n\n\n","tags":["算法"]},{"title":"初级排序算法","url":"%2F2019%2F09%2F22%2F%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F","content":"\n**Algorithms**这本书花了不少时间阅读，终于在某个时间点读完了。虽说读完了，但之前读的东西基本上也都忘得差不多了。预计抽出一些时间，不定期将这本书中的算法思想和java实现更新到此博客上。\n这是第一篇。\n排序算法的基础。\n\n* * *\n选择排序\n思想：找到数组中最小的元素，然后和数组第一个元素交换位置。再次，找到数组中第二小的元素，然后和数组第二个元素交换位置。如此反复，直到整个数组排序。\n以下为Java的实现： _仅提供必要的代码_\n\n```java\npublic class Selection {\n    private Selection() {\n    }\n\n    public void sort(Comparable[] a) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {// 选取数组的第一个元素\n            int min = i;\n            for (int j = i + 1; j < n; j++) {// 依次选取数组中剩余的元素\n                if (less(a[j], a[min]))\n                    min = j;// 选取数组中最小的元素\n            }\n            exch(a, i, min);\n            assert isSorted(a, 0, i);\n        }\n        assert isSorted(a);\n    }\n\n    private static boolean less(Comparable a, Comparable b) {\n        return a.compareTo(b) < 0;\n    }\n\n    private static void exch(Object[] a, int i, int j) {\n        Object t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n    }\n\n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length - 1);\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = 0; i < a.length; i++) {\n            if (less(a[i], a[i - 1]))\n                return false;\n        }\n        return true;\n    }\n}\n```\n\n插入算法\n思想：在一个数组中，把相邻的元素进行比较和交换，使各个元素处在恰当的位置上，直至此操作的索引到达数组的右端时，完成排序。\nJava实现：_仅提供必要的代码_\n\n```java\npublic class Insertion {\n    public void sort(Comparable[] a) {\n        int n = a.length;\n        for (int i = 1; i < n; i++) {\n            for (int j = i; j > 0 && less(a[j], a[j - 1]); j--) {\n                exch(a, j, j - 1);\n            }\n            assert isSorted(a, 0, i);\n        }\n        assert isSorted(a);\n    }\n\n    private static boolean less(Comparable a, Comparable b) {\n        return a.compareTo(b) < 0;\n    }\n\n    private static void exch(Object[] a, int i, int j) {\n        Object t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n    }\n\n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length);\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = lo + 1; i < hi; i++)\n            if (less(a[i], a[i - 1]))\n                return false;\n        return true;\n\n    }\n}\n```\n\n","tags":["算法"]},{"title":"KMP算法","url":"%2F2019%2F07%2F30%2FKMP%E7%AE%97%E6%B3%95%2F","content":"\nKMP算法，花了不少时间去理解。\n网络上说这个算法的内容很多~\n例如阮一峰的[博文](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)，应该说他讲的很清楚，但没有实现，所以只能理解到其中的思想。和《算法》第四版中描述的内容是有差异的。\n《算法》第四版中的KMP内容理解起来会比较费劲。原因可能是因为中文的翻译有时候完全基于原文，内容之间的联系有些割裂，当然英文好的话，推荐英文好的直接看原版。\n\n假设有一个长字符串文本(文本)和一个短字符串文本(模式)，现在需要我们做的是判断这个文本中是否存在与模式一样的子字符串。\n\n通常的暴力算法：\n首先，文本和模式都有指向自己字符的指针，指针的作用是为了说明正在比较的字符的位置。\n然后，将文本的第一个字符与模式的第一个字符进行比较，若匹配成功则继续将文本的指针移向下一个位置，同时也将模式的指针移向下一个位置继续进行字符比较，直到模式指针指向模式字符串的最后一位字符，且与文本中指针指向的字符匹配为止，即匹配成功。若期间匹配失败，则将文本指针移动到上一次匹配起始位置的下一个位置，将模式指针移动到模式字符串起始位置，对这两个位置的字符进行比较，若匹配则继续比较下一个位置的字符，若不匹配则继续移动文本指针到上一次匹配起始位置下一个位置，并且将模式指针退回到起始位置，继续比较两个位置的字符是否匹配。\n通常暴力子字符串查找法，在长度为N的文本中查找长度为M的模式，最坏需要~NM次比较。\n实现如下：\n```java\npublic static int search(String pat,String txt){\n  int j,M=pat.length();\n  int i,N=txt.length();\n  for(i=0,j=0;i<N&&j<M;i++){//i-=j和i++表示不匹配，则从匹配的起始位置的下一位开始重新匹配\n    if(txt.charAt(i)==pat.charAt(j)) j++;\n    else{i -= j;j=0}\n  }\n  if(j==M) return i-M;//匹配成功\n  else     return N;//匹配失败\n}\n```\n\nKMP算法：\n首先，文本和模式都有指向自己字符的指针，指针是用来说明文本和模式的哪个位置的字符正在进行比较。\n其次，这个算法中存在一个记录匹配失败时模式指针 j 应该指向哪个位置的数组dfa[][]，这个数组在文本指针 i 和模式指针 j 指向的字符匹配时，\n\n```java\ndfa[txt.charAt(i)][j] = j+1\n```\n\n即和文本指针在第 i+1 处的字符比较的是模式指针在第 j+1 处的字符，或者说当文本和模式一直匹配`dfa[][j]`的值一直增加，最终 j = M (模式字符串最后一个字符的索引)，即匹配成功。\n若文本指针第 i 处的字符与模式指针第 j 处的字符不匹配，则我们可以得到以下信息：\n已经匹配的文本字符是什么。因为这部分文本字符和模式中的部分内容是匹配的，即模式字符串的前 j 个字符。\n这里应该说明，j 是模式字符串的索引，从0开始计算，当文本字符串的 i 处字符和模式字符串的 j 处字符不匹配时候，之前已经匹配的字符的数量是 j (0...j-1) 个。\n\n至此，我们仅仅知道的是若匹配则`dfa[][j]`的值是不断增加的，若文本和模式在某个位置不匹配， `dfa[][]`又是怎么判断模式指针该退回去多远呢？\nKMP算法的主要思想是：「模式字符串中的某处可以和匹配失败处的正文相匹配，那么就不应该完全跳过所有已经匹配的所有字符」。KMP算法会提前判断如何重新开始查找，而这种判断仅取决于模式本身。\n翻译成大白话就是：文本和模式在某处不匹配，但模式中的某处和匹配失败处的字符串匹配，那么我们就不应该跳过这部分已匹配的字符，而应该将模式字符串的指针移动到该处，然后继续下一位的字符匹配。假设文本和模式分别在第 i 处和第 j 处不匹配，又文本中从 i-j 处开始到 i 位置的字符是已知的且前面的 j 个字符都是匹配的，仅 第 i 个位置的字符和模式不匹配，其实这些问题最终只归结于模式本身，因为匹配的部分就是模式中的字符。\n\n这里要说明一个概念：确定有限状态自动机。\n其组成包括：\n一个非空有限的状态集合𝑄；\n一个输入字母表∑；\n一个转移函数𝜕；\n一个开始状态𝙨 ∈ 𝑄 ；\n一个接受状态的集合F ⊆ 𝑄；\n其工作方式：\n确定有限状态自动机从起始状态开始，一个字符接一个字符的读入一个字符串w ( w ∈ ∑ )，并根据给定的转移函数一步一步地转移至下一个状态。在读完该字符串后，如果该自动机停在一个属于F的接受状态，那么它就接受该字符串，反之则拒绝该字符串。\n\n回到KMP算法中，\ndfa[][]数组本身定义的就是一个*确定有限状态自动机*。\n根据算法第四版中的内容可知，\n「一个非空有限的状态集合𝑄」-> 模式字符串中的每个索引值代表一种状态；\n「一个输入字母表∑」 -> 模式字符串的字母表；\n「一个转移函数𝜕」 -> 即判断文本字符和模式字符是否匹配；\n「一个开始状态𝙨 ∈ 𝑄 」 -> 状态0；\n「一个接受状态的集合F ⊆ 𝑄；」-> 状态M，即模式指针移动到模式字符串最后一个字符且与文本匹配时的`dfa[][]`状态；\ndfa[][]的工作方式：\ndfa[][]从状态0开始，一个字符接一个字符的读入模式字符串，将这些字符一个一个与文本中的字符进行比较，如果模式中的字符和文本中的字符匹配，则状态会依次改变，当最终达到状态M(即模式指针指向模式最后一个字符且与文本内容匹配时)时候，则表明文本中找到了一段与模式匹配的子字符，否则文本中不存在与模式匹配的子字符串。\n我们拿文本和模式中的字符一一对比，`dfa[][]`的状态会发生变化。当字符匹配，模式指针向右移动一位,即`dfa[][]`的状态向前进；当出现不匹配的情况，则模式指针的向左移动，移动位置会根据当前`dfa[][]`所处的状态不同而不同。在以上两种情况下，文本指针的位置一直是向右移动。\n\n那么当文本和模式出现不匹配的时候，`dfa[][]`的值怎么确定呢？毕竟这是告诉我们模式指针该退回多远的关键。\n假设文本的第 i 处和模式的第 j 处不匹配，\n首先，我们应当理解，文本中已经和模式匹配的字符的数量是 j 个，位置在 i-j 到 i-1 之间。\n我们希望了解的是，如果退回了文本指针并右移了一位之后，重新扫描这部分字符，(这部分文本字符和模式字符是相同的，即pat.charAt(1)~pat.charAt(j-1)之间的字符) `dfa[][]`的状态是什么，这个状态又叫做*重启状态X*。\n为什么要忽略pat.charAt(0)呢，因为模式需要右移一位(文本指针右移一位)，为什么忽略pat.charAt(j)呢，因为这个字符是匹配失败的。\n显然对于匹配的字符数量不同，则重启状态X的值是不同的，即`dfa[][]`的值不同，模式指针退回多远也不一样。\n例如模式的字符串是 ABABAC，则\n当 j = 0 时，文本和模式不匹配，必然是文本指针向右移动一位，这里不存在重启状态X；\n当 j = 1 时，文本和模式不匹配，此时与模式匹配的字符A，去掉首字符和不匹配字符，然后将剩余字符(不存在)和模式进行匹配，`dfa[][]`=0，则X = 0；\n当 j = 2 时，文本和模式不匹配，此时与模式匹配的字符为AB，去掉首字符和不匹配字符，然后将剩余字符(B)和模式进行匹配，`dfa[][]`=0，则X = 0\n当 j = 3 时，文本和模式不匹配，此时与模式匹配的字符为ABA，去掉首字符和不匹配字符，然后将剩余字符(BA)和模式进行匹配，`dfa[][]`=1，去掉首字符和不匹配字符，则X = 1\n当 j = 4 时，文本和模式不匹配，此时与模式匹配的字符为ABAB，去掉首字符和不匹配字符，然后将剩余字符(BAB)和模式进行匹配，`dfa[][]`=2，去掉首字符和不匹配字符，则X = 2\n当 j = 5 时，文本和模式不匹配，此时与模式匹配的字符为ABABA，去掉首字符和不匹配字符，然后将剩余字符(BABA)和模式进行匹配，`dfa[][]`=3，去掉首字符和不匹配字符，则X = 3\nj 即使模式指针，也是状态。\n\n此时，我们已经确定在文本和模式不匹配的时候，模式指针应该退回多远，即退回到重启状态X的位置。\n当模式指针退回到重启状态X的位置时，会继续进行匹配。\njava的完整实现如下：\n```java\npublic class KMP {\n    private final int R;\n    private int[][] dfa;//记录文本和模式不匹配时候，模式指针退回多远的值\n\n    private char[] pattern;\n    private String pat;\n\n    public KMP(String pat) {\n        this.R = 256;\n        this.pat = pat;\n\n        int m = pat.length();\n        dfa = new int[R][m];\n        dfa[pat.charAt(0)][0] = 1;\n        for (int x = 0, j = 1; j < m; j++) {\n            for (int c = 0; c < R; c++) {\n                //不匹配 文本i位置的可以是除匹配字符以外的任意字符，但在此位置的重启状态X都是一样的\n                dfa[c][j] = dfa[c][x];\n            }\n            //匹配,就是说只有dfa[pat.charAt(j)][j]的项才会使状态前进，不匹配的都会经重新状态X转到合适的位置\n            dfa[pat.charAt(j)][j] = j + 1;\n            x = dfa[pat.charAt(j)][x];//更新X 不同状态，对应的重启状态X不一样\n        }\n    }\n\n    public KMP(char[] pattern, int R) {\n        this.R = R;\n        this.pattern = new char[pattern.length];\n        for (int j = 0; j < pattern.length; j++) {\n            this.pattern[j] = pattern[j];\n        }\n\n        int m = pattern.length;\n        dfa = new int[R][m];\n        dfa[pattern[0]][0] = 1;\n        for (int x = 0, j = 1; j < m; j++) {\n            for (int c = 0; c < R; c++) {\n                dfa[c][j] = dfa[c][x];//不匹配\n            }\n            dfa[pattern[j]][j] = j + 1;//匹配\n            x = dfa[pattern[j]][x];//模式不同位置，对应的重启状态X不一样\n        }\n    }\n\n    public int search(String txt) {\n        int m = pat.length();\n        int n = txt.length();\n        int i, j;\n        for (i = 0, j = 0; i < n && j < m; i++) {\n            //只有dfa[txt.charAt(i)][j]==dfa[pat.charAt(j)][j],j才会等于j+1,即匹配。其他的情况，j会退回到之前的位置\n            j = dfa[txt.charAt(i)][j];\n        }\n        if (j == m) return i - m;//发现\n        return n;//未发现\n    }\n\n    public int search(char[] text) {\n        int m = pattern.length;\n        int n = text.length;\n        int i, j;\n        for (i = 0, j = 0; i < n && j < m; i++) {\n            j = dfa[text[i]][j];\n        }\n        if (j == m) return i - m;//发现\n        return n;//未发现\n    }\n\n    public static void main(String[] args) {\n        String pat = args[0];\n        String txt = args[1];\n        char[] pattern = pat.toCharArray();\n        char[] text = txt.toCharArray();\n\n        KMP kmp1 = new KMP(pat);\n        int offset1 = kmp1.search(txt);\n\n        KMP kmp2 = new KMP(pattern, 256);\n        int offset2 = kmp2.search(text);\n\n        StdOut.println(\"text:   \" + txt);\n        StdOut.print(\"pattern: \");\n        for (int i = 0; i < offset1; i++)\n            StdOut.print(\" \");\n        StdOut.println(pat);\n\n        StdOut.print(\"pattern: \");\n        for (int i = 0; i < offset2; i++)\n            StdOut.println();\n        StdOut.println(pat);\n    }\n}\n```\n\n讲的并不是很清楚，待更新~","tags":["算法"]},{"title":"学习和时间管理","url":"%2F2019%2F07%2F20%2F%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%2F","content":"\n<div style=“text-align:center>\n    <table cellpadding=\"3\" cellspacing=\"0\" style=\"width: 60%;margin:auto\">\n        <td>\n            <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=298 height=52 src=\"//music.163.com/outchain/player?type=2&id=760541&auto=0&height=32\"> </iframe>\n        </td>\n    </table>\n</div>\n\n学习新技能是一件让人开心的事情。\n回想起学生时代，除了填鸭式死记硬背，从没想过别的学习方式。\n以此，学的不好可想而知。另一个原因是每次考试的时候心理压力太大。\n不知何时起，这种时间跨度比较大的反思或者反省常常会伴随着和自己的和解。\n因为知道自己怎么了，才能找办法解决。\n\n学习其实最关键的还是理解+重复的次数足够多。\n但重复多了，有时会怀疑自己，怎么这么蠢连这点东西都理解不了。\n进而受挫，也许最后就放弃了。\n\n知识分为两类：一种侧重于了解某事物的名称。一种侧重于理解某事物本身。\n其实高中学到的大部分知识，都是浅尝辄止式的广撒网。\n而对于理解某事物本身的知识，如果有人说「这个东西我理解，但是不知道怎么去表达或者说出来能让别人理解」，这恰恰说明他不理解。因为既然一个东西你完全掌握了，理应可以用浅显直白的语言说出它所有的性质。\n这里套用一句话：\n**「说他知道自己的想法但却无法表达的人, 通常并不知道他自己的想法。 」**-- Mortimer Adler\n![study](https://isshl.me/img/study.jpg)\n从学习后知识的留存率来看，好为人师并不是坏事，你向别人说明一个事物的时候，正好可以用来检验你对所述内容的理解程度。\n当你向不熟悉某议题的人解释该议题的时候，以他们能理解的方式及最简单的语言向他们解释，\n倘若发现自己有不能理解的地方或者不能简单解释某议题的地方，恰恰这些是你对该议题理解薄弱的地方，\n这个时候应该回到原始材料中，重新学习理解薄弱的地方，一直到你能够以简单的语言来解释为止。\n重复以上步骤，直到你能完全理解这个议题为止。\n\n其实上面的内容，都是「费曼技巧」中的内容。\n而一旦你以这种方式去学习，\n其一，能够真正的了解任何你学习的事物。\n其二，做出深思熟虑并有智慧的决定。\n其三，熟练的将知识应用到实际问题中。\n\n以上~\n\n时间管理，是一个大的议题。相关的书籍很多很多。\n这些书所传述的「技能」，在现实生活中起多少作用，真的是靠自己如何将其和生活本身相结合了。\n时间就是生命~与其说是管理时间，不如说是管理好自己。\n以我自己来说，有时候觉得一丁点儿的娱乐都不应该存在，很大原因是觉得有好多东西需要去学习，成为更好的自己。\n所以玩一会，就觉得浪费时间。以前看过别人写的「为什么越努力越焦虑」，其核心的观点是：当你以「成为更好的自己」为目标，但「更好」并没有一个确切的定义，「更好」之外还有「更好」，你永远也达不到「最好」，最终努力成了目标本身，没有上限的目标一定会使你焦虑，一旦停止努力，就会陷入焦虑之中。\n但努力不是目标，它只是实现目标的手段。\n我们需要的，是具体确切的短期目标。\n尽量高效高质地完成短期目标，并及时收到反馈。这才是努力的正确姿势。\nvia--知乎:[以上观点来源链接](https://www.zhihu.com/question/37672919/answer/224810826)\n\n时间管理，本身应该结合实际的目标来制定。\n之前看《把时间当作朋友》一书，前3章的内容其实写的挺好，以下是关于此书的一点总结。\n\n背景：适用于短期或长期目标的实现\n1.制定可实现的目标\n2.倒推实现目标的步骤\n3.根据步骤制定任务\n4.将大的任务拆分成小的子任务\n5.将子任务拆分成更小的子任务--以最终可以完成为标准拆分\n6.将拆分的任务填入列表中\n7.估算任务的时间\n8.制定每日的任务列表\n9.执行\n\nTips:\n∙ 拆分任务应当遵循：做什么，为什么，怎么做 三原则。\n∙ 拆分任务后，应当寻找其中可以并行执行的任务，以提高效率。\n∙ 及时行动，立刻马上。\n∙ 每个任务：简单的部分应当迅速完成，困难部分多花时间。\n\n如果光说如何努力，或者光制定了计划而拖延执行，以上内容也就没了什么意义。\n之前浏览知乎，有搜到关于「如何保持自律」的内容。(ps:别问为什么又是知乎，问就是知乎干货多)\n\n假设存在6 7 8 9个坏习惯，比如熬夜、赖床、拖延......影响到你的自律，一般来说你肯定觉得要把这些坏习惯全部改掉，才能真正的自律。\n这样的思路，没错，但是实现起来很难。\n但其实，你只需要改变其中某个或者某些习惯即可，这些习惯一旦改变，则其他方面就会出现相应的改变，进而重塑生活/工作/学习方式。所以要找到影响你自律的最核心的坏习惯。\n「成功并不是要做对每一件事」，于我而言，其实跑步锻炼，就可以保持自律。\n所以，当你觉得自己不够自律的时候，请细心找找影响你自律最关键的习惯是什么，进而改变它，最终带来更多的改变。\n此处应推荐：[习惯的力量](https://zure.fun/book/8d41843e-4043-11e9-a197-560001e9d47e/)\n\n而其实「我就是不想做啊」更是生活常态。\n根据弗洛伊德的观点，每个人都存在「本我」「自我」「超我」的概念。\n偷懒拖延的本性，源于「本我」的「唯乐主义」。\n不断鞭策自己成长的是「超我」，是理想化的自己。\n而联系两者的是存在于中间的「自我」。\n请尝试将「超我」置于「管理者」和「引领者」的位置。\n本来作为「币圈大佬」的李笑来，人设已崩，而其写的那本《把时间当作朋友》，也不推荐读，前三章观点还可以，后面的章节写的非常乱，全是自我经验，与其费力去除其中的个人经验从而提炼出什么有价值的东西来，不如就别看。\n但其前三章中，有个观点是：我们可以用自己的大脑来控制我们的大脑。\n意思是，大脑本身是以「本我」的「唯乐主义」原则运行的，我们都「无意识地被自己的大脑所控制」，也就是「被负面情绪、唯乐主义指使，拖拖拉拉不愿做事」，我们应该意识到，「大脑」并不是「我自己」，而是属于「我」的，「我」是「我的大脑」的主人。\n也就是说，我们要意识到，自己在理性上具有主导地位。\n有意识地让「超我」去扮演「引领者」和「管理者」的角色，才是真正去主宰自己的生活。\n\n还有一种观点：「我」既是「我自己的老板」，也是「我自己的员工」。\n当你享受当老板时候的自我决策和掌控感时，也应该履行作为员工的职责。\n即我是我自己的老板，一切都是我说了算，我也是我自己的员工，我应该学会服从，\n**而不是想做就做，不想做就不做！**\n当然了，效果如何，还需实践~\n以上~\n\nPS: 评论系统来自Disqus，这玩意被防火墙封了。\nPPS:Pray for Kyoani.\n\n","tags":["时间管理"]},{"title":"一些回忆","url":"%2F2019%2F07%2F19%2F%E4%B8%80%E4%BA%9B%E5%9B%9E%E5%BF%86%2F","content":"\n龙珠是小学时候看的，1996年以后，具体几年级忘了。\n小学时代，对这些动漫的第一印象就是：很帅。那种帅是说，正义终将胜利。\n印象中只记得关于龙珠的几个片段，\n其一，有个叫曹振的同学说「孙悟空最后当了神啊」，还有他那张幼稚的小脸印象深刻。\n其二，借了张齐玉同学的漫画书，那会晚上和奶奶一起睡，所以那次借了书后，看到了很晚。\n日光灯在北面墙上挂着，噼噼啪啪的总有虫子的撞击声，那会住在郊区。\n其他的诸如，天空之城、铁胆火车侠、奥特曼、EVA、美少女战士、数码宝贝、超能勇士、蓝猫淘气三千问、葫芦娃等等等，都没剩多少印象了，连看的过程中的片段都不记得一丝一毫。\n\n刚看完了龙珠超：布罗利。龙珠这部动漫，大概到大学的时候，才看完所有的动画，即便看的早。之后这些超，貌似不是鸟山明出的就没看。\n要说这些事情，包括小学初中在记忆里只剩下符号，没有多少具体意义。\n要给它们定个基调，就是我觉得我开窍的时间太晚，到了高中才明白一些事情。\n不是我不想开窍，是因为那时候的执念太深，也只有一个：不想多和别人交流。\n嘛，不过现在也好不到哪去。\n\n人总会在某些时候，怜惜自己。觉得自己很无辜很无助也很无力。\n你不是孤单一个人。很多人都会如此，并没有谁就一定会没有这些情绪。\n有些人走出来，是因为相信自己。或者不相信也没关系。\n只要你能找点事情去做，一旦忙起来，这些焦虑抑郁等负面情绪，根本没得时间去想。\n讨好型的人格，最终会因为受到的伤害太多，选择冷漠。这很常见，但也真的没必要。\n除了同班同学，人这一辈子遇到的人，不会超过2000，真正相识的能有几个？\n遇到坏人，并不代表始终会遇到坏人。不要走极端，听话。\n\n我前前后后读了至少十几本心理学科普书，这些只是「技」，但指导生活足够。\n决定你现在的，不是过去发生的事情，而是你透过过去发生的事情，在此刻做出选择的结果。\n每一个选择背后都会关联着一个目的。你选择什么是为了什么。而这个目的，最终个人猜测是潜意识里那些没有得到满足的需求，最核心的不过是「爱」。应该说，过去不管发生了什么，它们都是中立的，而你因为某些目的，特意选择了某些记忆，以此来说明自己是个什么样的人 。既然是自己的选择，就可以重新选择，唯独缺少的是勇气罢了。\n建议看看《被讨厌的勇气》，此书我看了5遍+。[喜马拉雅的地址](https://www.ximalaya.com/youshengshu/2749527/)\n\n阿德勒的心理学，固然不能回答所有问题，但他提供了一个思路，那就是以足够的勇气去追求更好的自己，其中也包括如何处理人际关系，如何面对心理阴影等等。这本书虽然不是他的著作，但作者是研究阿德勒心理学的学者，提炼出来的观点，有些足够颠覆一般的认知。\n\n我希望你很好。\n以上~\n\n* * *\n日志\n修改内容：「标题」\n修改时间：2019年09月23日09:57:07\n\n\n\n","tags":["动漫"]},{"title":"从某次搜索谈起","url":"%2F2019%2F07%2F15%2F%E4%BB%8E%E6%9F%90%E6%AC%A1%E6%90%9C%E7%B4%A2%E8%B0%88%E8%B5%B7%2F","content":"之前有想法是从底层构建一个博客，后来想想工程量有点大，有现成的工具和框架不必花那些时间了。\n偶然某次搜索，搜到了一个博士建的博客站点。于是揣着一点好奇，把里面的文章随机浏览了一遍。\n[博客地址](http://songchunlin.net/cn/archive/)\n内容多数是关于生活的。技术类涉及不多，毕竟非CS类。\n博客的Timeline，是从2013年开始的。\n\n有一段时间，对于时间很敏感。因为以前浪费多了，觉得浪费一丁点儿都心疼，即便在没有事情做的时候，也很少会看点休闲的东西。这一年多，没有看完一部美剧或日剧。电影只完整看完了《流浪地球》。读书，kindle里存书太多，某些不值得看的书顺手删掉，细读的也不是特别多，只不过睡前总要翻几页。\n\n从某些方面来说，我相信除了那些天赋上必须具备条件的事情，一般而言，可以后天学习得到的，就一定可以获得的。至于是否值得践行「1万小时理论」，前段时间读的刻意学习更适合。而就学习这件事来说，质量的高低，和人是否主动投入很大关系。说到底，重复才是学习的精髓。当了那么多年学生，从来没把学习当作很重要的事情来看，也没有什么学习技巧。随波逐流的学，想当然的觉得这些东西没什么，最终会以各种形式影响到自己的生活。环境是非常重要的一件事情。\n\n知乎上有人说，一旦你开始锻炼，那么你的年龄将保持在你锻炼的那个阶段。事实上，锻炼最大的好处是可以化解很多不必要的负面情绪。我一直鼓励身边的人运动。至少我自己每周保持运动5次，每次30分钟不等。\n说回上面的博客，因为对页面的简洁有那么一丝要求。\n之前Hexo搭配的NexT主题，很常见。搞hackintosh的时候翻教程，十个里面有九个是这个主题，或是这个主题的魔改。github的加载速度，国内一言难尽，时快时慢，甚至我挂了梯子，也不快。\nHexo的主题，文件目录和内容比较固定，稍微套用了下博主的主题。\n于是很顺利搭建完成。\n对于markdown的使用，各种标记的使用还不熟。纯文字倒没什么。\n域名和梯子有一点花费。\n不过Hexo+Github建博客很容易，甚至域名都可以不用绑定，直接用github.io。\n希望能一直写下去。\n(完)\n* * *\n日志\n修改内容：删除部分多余文字\n修改时间：2019年09月23日10:04:18\n\n\n","tags":["技术应用"]},{"title":"关于一些问题的思考","url":"%2F2019%2F07%2F15%2F%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83%2F","content":"\n存在是客观的，但意义是空虚的。\n没有必要问出生活的意义是什么，创造了什么便是意义的全部。\n你是你选择的结果。\n主观的选择，背后一定有其目的。\n现在的你并不是由过去决定的，而是由当下的你决定的。\n你是先有的目的，再从过去寻找原因。\n换句话说，决定我们自身的不是过去的经历，而是我们赋予这些经历的意义。\n既然赋予是我们的选择，就可以再选一次。\n心理创伤本身也不存在，它是为了支持我们的目的而存在。不过感受是主观的，经历是客观的。\n你以为难的事情，做的时候，也许感到的是「不过如此」。\n","tags":["生活"]}]